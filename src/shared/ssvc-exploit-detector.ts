/**
 * SSVC Exploit Detection Utility
 *
 * Analyzes CVE references to determine the most accurate exploitation status
 * for SSVC (Stakeholder-Specific Vulnerability Categorization) decisions.
 *
 * This module helps override conservative CISA SSVC data when Vulnetix has
 * detected verified exploits or PoCs in the reference data.
 */

export interface ExploitDetectionResult {
    hasVerifiedExploit: boolean
    hasPoc: boolean
    exploitationLevel: 'none' | 'poc' | 'active'
    exploitSources: string[]
    confidence: number // 0-100
}

export interface ReferenceData {
    url: string
    type?: string
    subcategory?: string
    extractedData?: any
    verified?: boolean
    referenceSource?: string
    title?: string
}

/**
 * Determine exploitation level from CVE references
 *
 * Priority order:
 * 1. Verified Exploit-DB exploits (marked as verified or type='exploit')
 * 2. Metasploit modules (active exploits)
 * 3. Unverified Exploit-DB entries (type='poc')
 * 4. GitHub Gists with exploit indicators
 * 5. Other PoC sources
 */
export function detectExploitationLevel(
    references: ReferenceData[]
): ExploitDetectionResult {
    const result: ExploitDetectionResult = {
        hasVerifiedExploit: false,
        hasPoc: false,
        exploitationLevel: 'none',
        exploitSources: [],
        confidence: 0
    }

    if (!references || references.length === 0) {
        return result
    }

    const verifiedExploitSources = new Set<string>()
    const pocSources = new Set<string>()

    for (const ref of references) {
        const url = ref.url?.toLowerCase() || ''
        const type = ref.type?.toLowerCase() || ''
        const subcategory = ref.subcategory?.toLowerCase() || ''
        const source = ref.referenceSource || ''

        // Check for verified exploits

        // 1. Exploit-DB: marked as 'exploit' type or verified
        if (subcategory === 'exploit-db' || url.includes('exploit-db.com')) {
            if (type === 'exploit' || ref.verified === true) {
                result.hasVerifiedExploit = true
                verifiedExploitSources.add('Exploit-DB')
                result.confidence = Math.max(result.confidence, 95)
            } else {
                // Unverified Exploit-DB entries are considered PoCs
                result.hasPoc = true
                pocSources.add('Exploit-DB')
                result.confidence = Math.max(result.confidence, 75)
            }
            continue
        }

        // 2. Metasploit modules (always considered verified exploits)
        if (url.includes('metasploit') || source.includes('Metasploit')) {
            result.hasVerifiedExploit = true
            verifiedExploitSources.add('Metasploit')
            result.confidence = Math.max(result.confidence, 98)
            continue
        }

        // 3. Packet Storm Security exploits
        if (subcategory === 'packetstorm' || url.includes('packetstormsecurity.com')) {
            if (type === 'exploit') {
                result.hasVerifiedExploit = true
                verifiedExploitSources.add('Packet Storm')
                result.confidence = Math.max(result.confidence, 90)
            } else {
                result.hasPoc = true
                pocSources.add('Packet Storm')
                result.confidence = Math.max(result.confidence, 70)
            }
            continue
        }

        // 4. GitHub Gists (typically PoCs) - check before general GitHub
        if (url.includes('gist.github.com')) {
            result.hasPoc = true
            pocSources.add('GitHub Gist')
            result.confidence = Math.max(result.confidence, 60)
            continue
        }

        // 5. GitHub exploits (look for specific patterns)
        if (subcategory === 'github' || url.includes('github.com')) {
            const title = ref.title?.toLowerCase() || ''
            const hasExploitIndicator =
                title.includes('exploit') ||
                title.includes('weaponized') ||
                title.includes('攻击') || // Chinese for "attack"
                url.includes('/exploit') ||
                url.includes('poc-')

            // GitHub PoC repositories
            if (type === 'poc' || hasExploitIndicator) {
                result.hasPoc = true
                pocSources.add('GitHub')
                result.confidence = Math.max(result.confidence, 65)
            }
            continue
        }

        // 6. Sighting evidence (CrowdSec, honeypots, etc.)
        if (type === 'sighting') {
            result.hasVerifiedExploit = true
            verifiedExploitSources.add(source || 'Sighting')
            result.confidence = Math.max(result.confidence, 85)
            continue
        }

        // 7. Generic 'exploit' or 'poc' types
        if (type === 'exploit') {
            result.hasVerifiedExploit = true
            verifiedExploitSources.add(source || 'Unknown')
            result.confidence = Math.max(result.confidence, 80)
        } else if (type === 'poc') {
            result.hasPoc = true
            pocSources.add(source || 'Unknown')
            result.confidence = Math.max(result.confidence, 60)
        }
    }

    // Determine final exploitation level
    if (result.hasVerifiedExploit) {
        result.exploitationLevel = 'active'
        result.exploitSources = Array.from(verifiedExploitSources)
    } else if (result.hasPoc) {
        result.exploitationLevel = 'poc'
        result.exploitSources = Array.from(pocSources)
    }

    return result
}

/**
 * Determine if Vulnetix data should override CISA SSVC exploitation status
 *
 * Override scenarios:
 * 1. CISA says "none" but Vulnetix has verified exploit → Override to "active"
 * 2. CISA says "none" but Vulnetix has PoC → Override to "poc"
 * 3. CISA says "poc" but Vulnetix has verified exploit → Override to "active"
 *
 * @param cisaExploitation - CISA's exploitation status
 * @param vulnetixDetection - Vulnetix's exploitation detection result
 * @returns Override decision with reason
 */
export function shouldOverrideCisaExploitation(
    cisaExploitation: string | null | undefined,
    vulnetixDetection: ExploitDetectionResult
): {
    shouldOverride: boolean
    newExploitation: string | null
    reason: string | null
    sources: string[]
} {
    const normalizedCisa = cisaExploitation?.toLowerCase() || 'none'

    // No override needed if no exploit data found
    if (vulnetixDetection.exploitationLevel === 'none') {
        return {
            shouldOverride: false,
            newExploitation: null,
            reason: null,
            sources: []
        }
    }

    // Scenario 1: CISA says "none" but we have verified exploit
    if (normalizedCisa === 'none' && vulnetixDetection.hasVerifiedExploit) {
        return {
            shouldOverride: true,
            newExploitation: 'active',
            reason: `Vulnetix detected verified exploit(s) from ${vulnetixDetection.exploitSources.join(', ')}`,
            sources: vulnetixDetection.exploitSources
        }
    }

    // Scenario 2: CISA says "none" but we have PoC
    if (normalizedCisa === 'none' && vulnetixDetection.hasPoc) {
        return {
            shouldOverride: true,
            newExploitation: 'poc',
            reason: `Vulnetix detected PoC from ${vulnetixDetection.exploitSources.join(', ')}`,
            sources: vulnetixDetection.exploitSources
        }
    }

    // Scenario 3: CISA says "poc" but we have verified exploit
    if (normalizedCisa === 'poc' && vulnetixDetection.hasVerifiedExploit) {
        return {
            shouldOverride: true,
            newExploitation: 'active',
            reason: `Vulnetix upgraded to verified exploit from ${vulnetixDetection.exploitSources.join(', ')}`,
            sources: vulnetixDetection.exploitSources
        }
    }

    // No override needed
    return {
        shouldOverride: false,
        newExploitation: null,
        reason: null,
        sources: []
    }
}

/**
 * Enhanced SSVC decision options with Vulnetix override
 *
 * This function takes CISA SSVC options and applies Vulnetix overrides
 * based on detected exploit/PoC data from references
 */
export function applyVulnetixOverride(
    cisaOptions: Record<string, string>,
    references: ReferenceData[]
): {
    options: Record<string, string>
    wasOverridden: boolean
    overrideReason: string | null
    overrideSources: string[]
} {
    const detection = detectExploitationLevel(references)
    const cisaExploitation = cisaOptions.Exploitation || cisaOptions.exploitation
    const override = shouldOverrideCisaExploitation(cisaExploitation, detection)

    if (override.shouldOverride && override.newExploitation) {
        // Create new options with overridden exploitation
        const newOptions = { ...cisaOptions }

        // Update exploitation field (handle both capitalized and lowercase keys)
        if ('Exploitation' in newOptions) {
            newOptions.Exploitation = override.newExploitation.toUpperCase()
        }
        if ('exploitation' in newOptions) {
            newOptions.exploitation = override.newExploitation.toLowerCase()
        }

        return {
            options: newOptions,
            wasOverridden: true,
            overrideReason: override.reason,
            overrideSources: override.sources
        }
    }

    return {
        options: cisaOptions,
        wasOverridden: false,
        overrideReason: null,
        overrideSources: []
    }
}
