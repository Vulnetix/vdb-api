import { PrismaClient, SSVCPriority, SSVCSource } from '@prisma/client'
import { establishCVEAliasRelations } from './cve-alias-manager'
import { applyVulnetixOverride } from './ssvc-exploit-detector'
import { convertCvssV2ToV31 } from './cvss'

/**
 * CVE data storage utilities
 * Handles storing and retrieving CVE data from multiple sources (OSV, CVE.org, NVD, GitHub, etc.)
 */

export interface SSVCDecisionData {
    methodology: string // e.g., "CISA Coordinator", "AI/LLM Triage"
    methodologyVer: string // e.g., "2.0.3", "1.0"
    source: SSVCSource // Prisma enum: CISA_ADP, MANUAL, AUTOMATED, etc.
    decisionOutcome: string // e.g., "Act", "Track", "Track*"
    priority: SSVCPriority // Prisma enum: IMMEDIATE, HIGH, MEDIUM, LOW
    options: Record<string, string> // e.g., {"Exploitation": "active", "Automatable": "yes"}
    timestamp: number // Unix timestamp
    cveId?: string
    sourceData?: any // Full source data for audit trail
    // Vulnetix override metadata (when we override CISA data with better exploit intel)
    vulnetixOverride?: {
        wasOverridden: boolean
        originalExploitation?: string
        overriddenExploitation?: string
        reason?: string
        sources?: string[]
    }
}

export interface CVEProblemTypeData {
    containerType: 'cna' | 'adp'
    adpOrgId?: string
    cweId?: string
    description: string
    descriptionType?: 'text' | 'CWE' | 'other'
    lang?: string
}

export interface CVEMetricData {
    containerType: 'cna' | 'adp'
    adpOrgId?: string
    metricType: 'cvssV2_0' | 'cvssV3_0' | 'cvssV3_1' | 'cvssV4_0' | 'ssvc' | 'other'
    vectorString?: string
    baseScore?: number
    baseSeverity?: string
    metricFormat?: string
    scenarios?: any[]
    otherType?: string
    otherContent?: any
}

export interface CVEAffectedVersionData {
    version: string
    status: 'affected' | 'unaffected'
    versionType?: string
    lessThan?: string
    lessThanOrEqual?: string
    changes?: any[]
}

export interface CVEAffectedData {
    containerType: 'cna' | 'adp'
    adpOrgId?: string
    vendor?: string
    product?: string
    collectionURL?: string
    packageName?: string
    cpes?: string[]
    modules?: string[]
    programFiles?: string[]
    programRoutines?: string[]
    platforms?: string[]
    repo?: string
    defaultStatus?: string
    versions?: CVEAffectedVersionData[]
}

export interface CVEDescriptionData {
    containerType: 'cna' | 'adp'
    adpOrgId?: string
    lang?: string
    value: string
    supportingMedia?: any[]
}

export interface CVEImpactDescriptionData {
    lang: string
    value: string
}

export interface CVEImpactData {
    containerType: 'cna' | 'adp'
    adpOrgId?: string
    capecId?: string
    descriptions: CVEImpactDescriptionData[]
}

export interface CVESourceData {
    cveId: string
    source: 'osv' | 'cve.org' | 'nvd' | 'github' | 'euvd' | 'vulncheck' | 'finding' | 'cisa_adp' | 'anchore_adp' | 'google_osi' | 'other'
    dataVersion?: string
    state?: string
    datePublished?: number
    dateUpdated?: number
    dateReserved?: number
    vectorString?: string // Deprecated: use metrics array
    title?: string
    sourceAdvisoryRef?: string
    affectedVendor?: string // Deprecated: use affected array
    affectedProduct?: string // Deprecated: use affected array
    affectedVersions?: any[] // Deprecated: use affected array
    cpes?: string[] // Deprecated: use affected array
    cnaOrgId?: string
    cnaShortName?: string
    adpPublishers?: Array<{
        orgId: string
        shortName: string
        title: string
    }>
    ssvcDecisions?: SSVCDecisionData[] // SSVC decisions extracted from ADP or other sources
    references?: Array<{
        url: string
        type?: string
        title?: string
    }>
    problemTypes?: CVEProblemTypeData[] // CWE and other problem types
    metrics?: CVEMetricData[] // CVSS and other scoring metrics
    affected?: CVEAffectedData[] // Affected products and versions
    descriptions?: CVEDescriptionData[] // Descriptions with language support
    impacts?: CVEImpactData[] // CAPEC-based impact scenarios
    aliases?: string[] // Vulnerability aliases (e.g., EUVD ID for CVE, CVE ID for GHSA, etc.)
    rawData?: any
}

interface Logger {
    warn: (message: string, data?: any) => void
    debug: (message: string, data?: any) => void
    error: (message: string, data?: any) => void
    info: (message: string, data?: any) => void
}

/**
 * Store or update CVE data from a specific source
 * Uses upsert to handle both creation and updates
 */
export const storeCVEData = async (
    prisma: PrismaClient,
    data: CVESourceData,
    logger: Logger
): Promise<void> => {
    try {
        const now = Math.floor(Date.now() / 1000)

        // Prepare CNA (CVE Numbering Authority) if provided
        if (data.cnaOrgId && data.cnaShortName) {
            await prisma.cVENumberingAuthority.upsert({
                where: {
                    orgId: data.cnaOrgId
                },
                create: {
                    orgId: data.cnaOrgId,
                    shortName: data.cnaShortName
                },
                update: {
                    shortName: data.cnaShortName
                }
            })
        }

        // Get existing record to increment fetch count
        // Using composite key (cveId, source) to support multiple sources per CVE
        const existing = await prisma.cVEMetadata.findUnique({
            where: {
                cveId_source: {
                    cveId: data.cveId,
                    source: data.source
                }
            }
        })

        logger.info(`Storing CVE ${data.cveId} from source ${data.source}`)

        // Store CVE metadata with source tracking
        // Using composite key to allow multiple sources per CVE
        await prisma.cVEMetadata.upsert({
            where: {
                cveId_source: {
                    cveId: data.cveId,
                    source: data.source
                }
            },
            create: {
                cveId: data.cveId,
                source: data.source,
                dataVersion: data.dataVersion || '1.0',
                state: data.state || 'PUBLISHED',
                datePublished: data.datePublished || now,
                dateUpdated: data.dateUpdated,
                dateReserved: data.dateReserved,
                vectorString: data.vectorString,
                title: data.title,
                sourceAdvisoryRef: data.sourceAdvisoryRef,
                affectedVendor: data.affectedVendor,
                affectedProduct: data.affectedProduct,
                affectedVersionsJSON: data.affectedVersions ? JSON.stringify(data.affectedVersions) : null,
                cpesJSON: data.cpes ? JSON.stringify(data.cpes) : null,
                cnaOrgId: data.cnaOrgId,
                lastFetchedAt: now,
                fetchCount: 1,
                rawDataJSON: data.rawData ? JSON.stringify(data.rawData) : null
            },
            update: {
                dataVersion: data.dataVersion || '1.0',
                state: data.state || 'PUBLISHED',
                datePublished: data.datePublished || now,
                dateUpdated: data.dateUpdated,
                dateReserved: data.dateReserved,
                vectorString: data.vectorString,
                title: data.title,
                sourceAdvisoryRef: data.sourceAdvisoryRef,
                affectedVendor: data.affectedVendor,
                affectedProduct: data.affectedProduct,
                affectedVersionsJSON: data.affectedVersions ? JSON.stringify(data.affectedVersions) : null,
                cpesJSON: data.cpes ? JSON.stringify(data.cpes) : null,
                cnaOrgId: data.cnaOrgId,
                lastFetchedAt: now,
                fetchCount: (existing?.fetchCount || 0) + 1,
                rawDataJSON: data.rawData ? JSON.stringify(data.rawData) : null
            }
        })

        // Store ADP (Authorized Data Publisher) relationships if provided
        if (data.adpPublishers && data.adpPublishers.length > 0) {
            for (const adp of data.adpPublishers) {
                // Ensure ADP exists
                await prisma.authorizedDataPublisher.upsert({
                    where: {
                        orgId: adp.orgId
                    },
                    create: {
                        orgId: adp.orgId,
                        shortName: adp.shortName,
                        title: adp.title
                    },
                    update: {
                        shortName: adp.shortName,
                        title: adp.title
                    }
                })

                // Create ADP relationship using composite key
                // Check if relationship already exists for this CVE+source+ADP combination
                const existingADP = await prisma.cVEADP.findFirst({
                    where: {
                        cveId: data.cveId,
                        source: data.source,
                        adpId: adp.orgId
                    }
                })

                if (!existingADP) {
                    await prisma.cVEADP.create({
                        data: {
                            cveId: data.cveId,
                            source: data.source,
                            adpId: adp.orgId
                        }
                    })
                }
            }
        }

        // Store detailed CVE data (problem types, metrics, affected, descriptions, impacts)
        if (data.problemTypes && data.problemTypes.length > 0) {
            await storeCVEProblemTypes(prisma, data.cveId, data.source, data.problemTypes, logger)
        }

        if (data.metrics && data.metrics.length > 0) {
            await storeCVEMetrics(prisma, data.cveId, data.source, data.metrics, logger)
        }

        if (data.affected && data.affected.length > 0) {
            await storeCVEAffected(prisma, data.cveId, data.source, data.affected, logger)
        }

        if (data.descriptions && data.descriptions.length > 0) {
            await storeCVEDescriptions(prisma, data.cveId, data.source, data.descriptions, logger)
        }

        if (data.impacts && data.impacts.length > 0) {
            // Convert CVEImpactData to format expected by storeCVEImpacts
            for (const impact of data.impacts) {
                const impactsData = [{
                    capecId: impact.capecId,
                    descriptions: impact.descriptions
                }]
                await storeCVEImpacts(
                    prisma,
                    data.cveId,
                    data.source,
                    impact.containerType,
                    impactsData,
                    impact.adpOrgId || null,
                    logger
                )
            }
        }

        // Establish alias relations if aliases are provided
        if (data.aliases && data.aliases.length > 0) {
            await establishCVEAliasRelations(
                prisma,
                data.cveId,
                data.source,
                data.aliases,
                data.source,
                logger
            )
        }

        logger.info(`[CVE Storage] Stored CVE data: ${data.cveId} from source: ${data.source}`)
    } catch (error) {
        logger.error(`[CVE Storage] Failed to store CVE data: ${data.cveId}`, { error })
        throw error
    }
}

/**
 * Store SSVC decisions from CVE data
 * Note: This requires a findingUuid - call from finding processor context
 */
export const storeSSVCDecisions = async (
    prisma: PrismaClient,
    findingUuid: string,
    ssvcDecisions: SSVCDecisionData[],
    triageUuid: string | null,
    logger: Logger
): Promise<void> => {
    try {
        if (!ssvcDecisions || ssvcDecisions.length === 0) {
            return
        }

        logger.info(`[CVE Storage] Storing ${ssvcDecisions.length} SSVC decision(s) for finding ${findingUuid}`)

        for (const decision of ssvcDecisions) {
            // Include Vulnetix override metadata in sourceDataJSON if present
            const sourceDataWithOverride = decision.sourceData
                ? {
                    ...decision.sourceData,
                    vulnetixOverride: decision.vulnetixOverride
                }
                : decision.vulnetixOverride
                    ? { vulnetixOverride: decision.vulnetixOverride }
                    : null

            await prisma.sSVCDecision.create({
                data: {
                    findingUuid,
                    triageUuid,
                    methodology: decision.methodology,
                    methodologyVer: decision.methodologyVer,
                    source: decision.source,
                    decisionOutcome: decision.decisionOutcome,
                    priority: decision.priority,
                    optionsJSON: JSON.stringify(decision.options),
                    timestamp: decision.timestamp,
                    cveId: decision.cveId,
                    sourceDataJSON: sourceDataWithOverride ? JSON.stringify(sourceDataWithOverride) : null
                }
            })

            const overrideInfo = decision.vulnetixOverride?.wasOverridden
                ? ` [Vulnetix Override: ${decision.vulnetixOverride.originalExploitation} → ${decision.vulnetixOverride.overriddenExploitation}]`
                : ''
            logger.info(`[CVE Storage] Stored SSVC decision: ${decision.methodology} v${decision.methodologyVer} - ${decision.decisionOutcome} (${decision.priority})${overrideInfo}`)
        }
    } catch (error) {
        logger.error(`[CVE Storage] Failed to store SSVC decisions for finding ${findingUuid}`, { error })
        throw error
    }
}

/**
 * Retrieve CVE data from a specific source
 */
export const getCVEDataBySource = async (
    prisma: PrismaClient,
    cveId: string,
    source: string,
    logger: Logger
): Promise<any | null> => {
    try {
        const cveData = await prisma.cVEMetadata.findUnique({
            where: {
                cveId_source: {
                    cveId,
                    source
                }
            },
            include: {
                cna: true,
                fileLink: true,
                adp: {
                    include: {
                        adp: true
                    }
                }
            }
        })

        return cveData
    } catch (error) {
        logger.error(`[CVE Storage] Failed to retrieve CVE data: ${cveId} from ${source}`, { error })
        return null
    }
}

/**
 * Retrieve all CVE data for a specific CVE ID from all sources
 */
export const getAllCVEDataSources = async (
    prisma: PrismaClient,
    cveId: string,
    logger: Logger
): Promise<any[]> => {
    try {
        const cveDataList = await prisma.cVEMetadata.findMany({
            where: {
                cveId
            },
            include: {
                cna: true,
                fileLink: true,
                adp: {
                    include: {
                        adp: true
                    }
                }
            },
            orderBy: [
                {
                    // Order by source priority
                    source: 'asc'
                },
                {
                    lastFetchedAt: 'desc'
                }
            ]
        })

        return cveDataList
    } catch (error) {
        logger.error(`[CVE Storage] Failed to retrieve all CVE data sources: ${cveId}`, { error })
        return []
    }
}

/**
 * Get the "best" CVE data for a specific CVE ID
 * Prioritizes sources in this order: cve.org > nvd > github > osv > other
 */
export const getBestCVEData = async (
    prisma: PrismaClient,
    cveId: string,
    logger: Logger
): Promise<any | null> => {
    try {
        const allSources = await getAllCVEDataSources(prisma, cveId, logger)

        if (allSources.length === 0) {
            return null
        }

        // Priority mapping
        const sourcePriority: Record<string, number> = {
            'cve.org': 1,
            'nvd': 2,
            'github': 3,
            'euvd': 4,
            'osv': 5,
            'vulncheck': 6,
            'other': 7
        }

        // Sort by priority, then by lastFetchedAt (most recent first)
        const sorted = allSources.sort((a, b) => {
            const priorityA = sourcePriority[a.source] || 99
            const priorityB = sourcePriority[b.source] || 99

            if (priorityA !== priorityB) {
                return priorityA - priorityB
            }

            return b.lastFetchedAt - a.lastFetchedAt
        })

        return sorted[0]
    } catch (error) {
        logger.error(`[CVE Storage] Failed to get best CVE data: ${cveId}`, { error })
        return null
    }
}

/**
 * Extract CVE ID from various formats (finding title, aliases, etc.)
 */
export const extractCVEId = (text: string | string[] | null | undefined): string | null => {
    if (!text) return null

    const cvePattern = /CVE-\d{4}-\d{4,}/gi

    if (typeof text === 'string') {
        const matches = text.match(cvePattern)
        return matches ? matches[0].toUpperCase() : null
    }

    if (Array.isArray(text)) {
        for (const item of text) {
            const match = extractCVEId(item)
            if (match) return match
        }
    }

    return null
}

/**
 * Check if CVE data needs refresh based on last fetch time
 * @param lastFetchedAt - Unix timestamp of last fetch
 * @param maxAgeSeconds - Maximum age in seconds (default: 24 hours)
 */
export const needsCVERefresh = (lastFetchedAt: number, maxAgeSeconds: number = 86400): boolean => {
    const now = Math.floor(Date.now() / 1000)
    return (now - lastFetchedAt) > maxAgeSeconds
}

/**
 * Parse OSV response to CVE data format
 */
export const parseOSVToCVE = (osvData: any, cveId: string): CVESourceData | null => {
    try {
        const data: CVESourceData = {
            cveId,
            source: 'osv',
            dataVersion: '1.0',
            state: osvData.withdrawn ? 'REJECTED' : 'PUBLISHED',
            datePublished: osvData.published ? new Date(osvData.published).getTime() / 1000 : undefined,
            dateUpdated: osvData.modified ? new Date(osvData.modified).getTime() / 1000 : undefined,
            title: osvData.summary || osvData.details,
            sourceAdvisoryRef: osvData.references?.[0]?.url,
            affectedVersions: osvData.affected?.map((a: any) => ({
                package: a.package?.name,
                ecosystem: a.package?.ecosystem,
                ranges: a.ranges
            })),
            rawData: osvData
        }

        // Extract CVSS if available
        if (osvData.severity) {
            const cvssEntry = osvData.severity.find((s: any) => s.type === 'CVSS_V3')
            if (cvssEntry) {
                data.vectorString = cvssEntry.score
            }
        }

        // Extract references
        if (osvData.references && Array.isArray(osvData.references)) {
            data.references = osvData.references
                .filter((ref: any) => ref?.url)
                .map((ref: any) => ({
                    url: ref.url,
                    type: ref.type
                }))
            console.log(`[parseOSVToCVE] Extracted ${data.references.length} references from OSV data for ${cveId}`)
        } else {
            console.log(`[parseOSVToCVE] No references found in OSV data for ${cveId}`)
        }

        // Extract aliases and related IDs using the comprehensive extractor
        const { aliases, related } = extractAllOSVAliases(osvData)

        // Combine aliases and related into a single array for CVEAlias relations
        // Both should be treated as related vulnerability identifiers
        if (aliases.length > 0 || related.length > 0) {
            data.aliases = [...new Set([...aliases, ...related])]
            console.log(`[parseOSVToCVE] Extracted ${aliases.length} aliases and ${related.length} related IDs from OSV data for ${cveId}`)
        }

        return data
    } catch (error) {
        return null
    }
}

/**
 * Extract all aliases from OSV data including direct aliases, related, and downstream identifiers
 * Returns comprehensive list: GHSA-*, PYSEC-*, DEBIAN-*, RHSA-*, SUSE-*, etc.
 */
export const extractAllOSVAliases = (osvData: any): { aliases: string[], related: string[] } => {
    const aliases: string[] = []
    const related: string[] = []

    try {
        // Extract direct aliases (GHSA-*, PYSEC-*, GO-*, RUSTSEC-*, etc.)
        if (osvData.aliases && Array.isArray(osvData.aliases)) {
            aliases.push(...osvData.aliases.filter((a: string) => a && typeof a === 'string'))
        }

        // Extract related vulnerabilities (DEBIAN-*, RHSA-*, SUSE-*, MGASA-*, etc.)
        if (osvData.related && Array.isArray(osvData.related)) {
            related.push(...osvData.related.filter((r: string) => r && typeof r === 'string'))
        }

        // Deduplicate
        const uniqueAliases = [...new Set(aliases)]
        const uniqueRelated = [...new Set(related)]

        return {
            aliases: uniqueAliases,
            related: uniqueRelated
        }
    } catch (error) {
        return { aliases: [], related: [] }
    }
}

/**
 * Map CISA SSVC decision outcomes to priority levels
 */
const CISA_SSVC_PRIORITY_MAP: Record<string, SSVCPriority> = {
    'Act': SSVCPriority.IMMEDIATE,
    'Attend': SSVCPriority.HIGH,
    'Track*': SSVCPriority.MEDIUM,
    'Track': SSVCPriority.LOW
}

/**
 * Extract SSVC decisions from CISA ADP metrics
 * @param adpContainers - ADP containers from CVE data
 * @param cveId - CVE identifier
 * @param logger - Logger instance
 * @param references - CVE references for exploit detection (optional)
 */
const extractSSVCFromADP = (adpContainers: any[], cveId: string, logger?: any, references?: any[]): SSVCDecisionData[] => {
    // Create safe logger wrapper to prevent "is not a function" errors
    const safeLogger = {
        info: (msg: string, ...args: any[]) => {
            try { if (logger && typeof logger.info === 'function') logger.info(msg, ...args); } catch (e) { /* ignore */ }
        },
        debug: (msg: string, ...args: any[]) => {
            try { if (logger && typeof logger.debug === 'function') logger.debug(msg, ...args); } catch (e) { /* ignore */ }
        }
    };

    const decisions: SSVCDecisionData[] = []

    if (!adpContainers || !Array.isArray(adpContainers)) {
        return decisions
    }

    for (const container of adpContainers) {
        if (!container.metrics || !Array.isArray(container.metrics)) {
            continue
        }

        // Look for SSVC metrics in the ADP container
        for (const metric of container.metrics) {
            if (metric.other && metric.other.type === 'ssvc' && metric.other.content) {
                const content = metric.other.content

                // Extract decision options from the SSVC content
                const options: Record<string, string> = {}
                if (content.options && Array.isArray(content.options)) {
                    for (const option of content.options) {
                        // Each option is an object with a single key-value pair
                        const keys = Object.keys(option)
                        if (keys.length > 0) {
                            const key = keys[0]
                            options[key] = option[key]
                        }
                    }
                }

                // Apply Vulnetix override if references are available
                let finalOptions = options
                let vulnetixOverride: any = undefined

                if (references && references.length > 0) {
                    const overrideResult = applyVulnetixOverride(options, references)
                    if (overrideResult.wasOverridden) {
                        finalOptions = overrideResult.options
                        vulnetixOverride = {
                            wasOverridden: true,
                            originalExploitation: options['Exploitation'],
                            overriddenExploitation: finalOptions['Exploitation'],
                            reason: overrideResult.overrideReason,
                            sources: overrideResult.overrideSources
                        }

                        safeLogger.info(`[CVE Storage] Vulnetix overriding CISA SSVC for ${cveId}: ${options['Exploitation']} → ${finalOptions['Exploitation']} (${overrideResult.overrideReason})`)
                    }
                }

                // Determine decision outcome and priority based on CISA methodology
                // For CISA Coordinator, the decision is derived from the combination of decision points
                let decisionOutcome = 'Track' // Default
                let priority: SSVCPriority = SSVCPriority.LOW // Default

                // CISA Coordinator decision logic (simplified)
                // Act: Exploitation=active && (Automatable=yes || Technical Impact=total)
                // Attend: Exploitation=poc && (Automatable=yes || Technical Impact=total)
                // Track*: Exploitation=none && (Automatable=yes || Technical Impact=total)
                // Track: Everything else
                const exploitation = finalOptions['Exploitation']?.toLowerCase()
                const automatable = finalOptions['Automatable']?.toLowerCase()
                const technicalImpact = finalOptions['Technical Impact']?.toLowerCase()

                if (exploitation === 'active' && (automatable === 'yes' || technicalImpact === 'total')) {
                    decisionOutcome = 'Act'
                    priority = SSVCPriority.IMMEDIATE
                } else if (exploitation === 'poc' && (automatable === 'yes' || technicalImpact === 'total')) {
                    decisionOutcome = 'Attend'
                    priority = SSVCPriority.HIGH
                } else if (exploitation === 'none' && (automatable === 'yes' || technicalImpact === 'total')) {
                    decisionOutcome = 'Track*'
                    priority = SSVCPriority.MEDIUM
                } else {
                    decisionOutcome = 'Track'
                    priority = SSVCPriority.LOW
                }

                const decision: SSVCDecisionData = {
                    methodology: content.role || 'CISA Coordinator',
                    methodologyVer: content.version || '2.0.3',
                    source: SSVCSource.CISA_ADP,
                    decisionOutcome,
                    priority,
                    options: finalOptions,
                    timestamp: content.timestamp ? Math.floor(new Date(content.timestamp).getTime() / 1000) : Math.floor(Date.now() / 1000),
                    cveId,
                    sourceData: metric,
                    vulnetixOverride
                }

                decisions.push(decision)

                safeLogger.info(`[CVE Storage] Extracted SSVC decision from ${decision.source}: ${decisionOutcome} (${priority}) for ${cveId}`)
            }
        }
    }

    return decisions
}

/**
 * Extract problem types (CWE) from a container
 */
const extractProblemTypes = (container: any, containerType: 'cna' | 'adp', adpOrgId?: string): CVEProblemTypeData[] => {
    const problemTypes: CVEProblemTypeData[] = []

    if (!container?.problemTypes || !Array.isArray(container.problemTypes)) {
        return problemTypes
    }

    for (const problemType of container.problemTypes) {
        if (problemType.descriptions && Array.isArray(problemType.descriptions)) {
            for (const desc of problemType.descriptions) {
                problemTypes.push({
                    containerType,
                    adpOrgId,
                    cweId: desc.cweId,
                    description: desc.description || desc.value,
                    descriptionType: desc.type || (desc.cweId ? 'CWE' : 'text'),
                    lang: desc.lang || 'en'
                })
            }
        }
    }

    return problemTypes
}

/**
 * Extract metrics (CVSS, SSVC, etc.) from a container
 */
const extractMetrics = (container: any, containerType: 'cna' | 'adp', adpOrgId?: string): CVEMetricData[] => {
    const metrics: CVEMetricData[] = []

    if (!container?.metrics || !Array.isArray(container.metrics)) {
        return metrics
    }

    for (const metric of container.metrics) {
        // CVSS v2.0
        if (metric.cvssV2_0) {
            metrics.push({
                containerType,
                adpOrgId,
                metricType: 'cvssV2_0',
                vectorString: metric.cvssV2_0.vectorString,
                baseScore: metric.cvssV2_0.baseScore,
                baseSeverity: metric.cvssV2_0.baseSeverity,
                metricFormat: metric.format,
                scenarios: metric.scenarios
            })
        }

        // CVSS v3.0
        if (metric.cvssV3_0) {
            metrics.push({
                containerType,
                adpOrgId,
                metricType: 'cvssV3_0',
                vectorString: metric.cvssV3_0.vectorString,
                baseScore: metric.cvssV3_0.baseScore,
                baseSeverity: metric.cvssV3_0.baseSeverity,
                metricFormat: metric.format,
                scenarios: metric.scenarios
            })
        }

        // CVSS v3.1
        if (metric.cvssV3_1) {
            metrics.push({
                containerType,
                adpOrgId,
                metricType: 'cvssV3_1',
                vectorString: metric.cvssV3_1.vectorString,
                baseScore: metric.cvssV3_1.baseScore,
                baseSeverity: metric.cvssV3_1.baseSeverity,
                metricFormat: metric.format,
                scenarios: metric.scenarios
            })
        }

        // CVSS v4.0
        if (metric.cvssV4_0) {
            metrics.push({
                containerType,
                adpOrgId,
                metricType: 'cvssV4_0',
                vectorString: metric.cvssV4_0.vectorString,
                baseScore: metric.cvssV4_0.baseScore,
                baseSeverity: metric.cvssV4_0.baseSeverity,
                metricFormat: metric.format,
                scenarios: metric.scenarios
            })
        }

        // Other metrics (SSVC, custom)
        if (metric.other) {
            metrics.push({
                containerType,
                adpOrgId,
                metricType: 'other',
                otherType: metric.other.type,
                otherContent: metric.other.content,
                metricFormat: metric.format,
                scenarios: metric.scenarios
            })
        }
    }

    return metrics
}

/**
 * Extract affected products and versions from a container
 */
const extractAffected = (container: any, containerType: 'cna' | 'adp', adpOrgId?: string): CVEAffectedData[] => {
    const affected: CVEAffectedData[] = []

    if (!container?.affected || !Array.isArray(container.affected)) {
        return affected
    }

    for (const affectedItem of container.affected) {
        const versions: CVEAffectedVersionData[] = []

        // Extract versions
        if (affectedItem.versions && Array.isArray(affectedItem.versions)) {
            for (const version of affectedItem.versions) {
                versions.push({
                    version: version.version,
                    status: version.status,
                    versionType: version.versionType,
                    lessThan: version.lessThan,
                    lessThanOrEqual: version.lessThanOrEqual,
                    changes: version.changes
                })
            }
        }

        affected.push({
            containerType,
            adpOrgId,
            vendor: affectedItem.vendor,
            product: affectedItem.product,
            collectionURL: affectedItem.collectionURL,
            packageName: affectedItem.packageName,
            cpes: affectedItem.cpes,
            modules: affectedItem.modules,
            programFiles: affectedItem.programFiles,
            programRoutines: affectedItem.programRoutines,
            platforms: affectedItem.platforms,
            repo: affectedItem.repo,
            defaultStatus: affectedItem.defaultStatus,
            versions
        })
    }

    return affected
}

/**
 * Extract descriptions from a container
 */
const extractDescriptions = (container: any, containerType: 'cna' | 'adp', adpOrgId?: string): CVEDescriptionData[] => {
    const descriptions: CVEDescriptionData[] = []

    if (!container?.descriptions || !Array.isArray(container.descriptions)) {
        return descriptions
    }

    for (const desc of container.descriptions) {
        descriptions.push({
            containerType,
            adpOrgId,
            lang: desc.lang || 'en',
            value: desc.value,
            supportingMedia: desc.supportingMedia
        })
    }

    return descriptions
}

/**
 * Extract impacts (CAPEC-based scenarios) from a container
 */
const extractImpacts = (container: any, containerType: 'cna' | 'adp', adpOrgId?: string): CVEImpactData[] => {
    const impacts: CVEImpactData[] = []

    if (!container?.impacts || !Array.isArray(container.impacts)) {
        return impacts
    }

    for (const impact of container.impacts) {
        if (!impact.descriptions || !Array.isArray(impact.descriptions)) {
            continue
        }

        const descriptions: CVEImpactDescriptionData[] = []
        for (const desc of impact.descriptions) {
            descriptions.push({
                lang: desc.lang || 'en',
                value: desc.value
            })
        }

        impacts.push({
            containerType,
            adpOrgId,
            capecId: impact.capecId,
            descriptions
        })
    }

    return impacts
}

/**
 * Parse CVE.org response to CVE data format with full cvelistv5 support
 */
export const parseCVEOrgToCVE = (cveOrgData: any, logger?: any): CVESourceData | null => {
    // Create a safe logger wrapper to prevent "is not a function" errors
    const safeLogger = {
        info: (msg: string, ...args: any[]) => {
            try {
                if (logger && typeof logger.info === 'function') {
                    logger.info(msg, ...args);
                }
            } catch (e) { /* ignore */ }
        },
        warn: (msg: string, ...args: any[]) => {
            try {
                if (logger && typeof logger.warn === 'function') {
                    logger.warn(msg, ...args);
                }
            } catch (e) { /* ignore */ }
        },
        error: (msg: string, ...args: any[]) => {
            try {
                if (logger && typeof logger.error === 'function') {
                    logger.error(msg, ...args);
                }
            } catch (e) { /* ignore */ }
        },
        debug: (msg: string, ...args: any[]) => {
            try {
                if (logger && typeof logger.debug === 'function') {
                    logger.debug(msg, ...args);
                }
            } catch (e) { /* ignore */ }
        }
    };

    try {
        // Extract cveId from either published format (cveMetadata.cveId) or RESERVED format (cve_id)
        const cveId = cveOrgData.cveMetadata?.cveId || cveOrgData.cve_id
        const state = cveOrgData.cveMetadata?.state || cveOrgData.state

        // Validate cveId exists
        if (!cveId) {
            safeLogger.error('[parseCVEOrgToCVE] No CVE ID found in CVE.org data');
            return null
        }

        // Handle RESERVED state - create minimal record
        if (state === 'RESERVED') {
            safeLogger.info(`[CVE Parser] ${cveId} is in RESERVED state, creating minimal record`);
            return {
                cveId,
                source: 'cve.org',
                dataVersion: 'reserved',
                state: 'RESERVED',
                datePublished: Math.floor(Date.now() / 1000), // Use current timestamp
                dateReserved: cveOrgData.cveMetadata?.dateReserved
                    ? new Date(cveOrgData.cveMetadata.dateReserved).getTime() / 1000
                    : undefined,
                rawData: cveOrgData,
                problemTypes: [],
                metrics: [],
                affected: [],
                descriptions: [],
                impacts: []
            }
        }

        const data: CVESourceData = {
            cveId,
            source: 'cve.org',
            dataVersion: cveOrgData.dataVersion || '5.0',
            state: state || 'PUBLISHED',
            datePublished: cveOrgData.cveMetadata?.datePublished ? new Date(cveOrgData.cveMetadata.datePublished).getTime() / 1000 : undefined,
            dateUpdated: cveOrgData.cveMetadata?.dateUpdated ? new Date(cveOrgData.cveMetadata.dateUpdated).getTime() / 1000 : undefined,
            dateReserved: cveOrgData.cveMetadata?.dateReserved ? new Date(cveOrgData.cveMetadata.dateReserved).getTime() / 1000 : undefined,
            title: cveOrgData.containers?.cna?.title || cveOrgData.containers?.cna?.descriptions?.[0]?.value,
            sourceAdvisoryRef: cveOrgData.containers?.cna?.references?.[0]?.url,
            cnaOrgId: cveOrgData.containers?.cna?.providerMetadata?.orgId,
            cnaShortName: cveOrgData.containers?.cna?.providerMetadata?.shortName,
            rawData: cveOrgData,
            problemTypes: [],
            metrics: [],
            affected: [],
            descriptions: [],
            impacts: []
        }

        // Extract data from CNA container
        const cnaContainer = cveOrgData.containers?.cna
        if (cnaContainer) {
            data.problemTypes.push(...extractProblemTypes(cnaContainer, 'cna'))
            data.metrics.push(...extractMetrics(cnaContainer, 'cna'))
            data.affected.push(...extractAffected(cnaContainer, 'cna'))
            data.descriptions.push(...extractDescriptions(cnaContainer, 'cna'))
            data.impacts.push(...extractImpacts(cnaContainer, 'cna'))
        }

        // Extract data from ADP containers
        const adpContainers = cveOrgData.containers?.adp
        if (adpContainers && Array.isArray(adpContainers)) {
            for (const adpContainer of adpContainers) {
                const adpOrgId = adpContainer.providerMetadata?.orgId
                data.problemTypes.push(...extractProblemTypes(adpContainer, 'adp', adpOrgId))
                data.metrics.push(...extractMetrics(adpContainer, 'adp', adpOrgId))
                data.affected.push(...extractAffected(adpContainer, 'adp', adpOrgId))
                data.descriptions.push(...extractDescriptions(adpContainer, 'adp', adpOrgId))
                data.impacts.push(...extractImpacts(adpContainer, 'adp', adpOrgId))
            }
        }

        // Legacy: Extract CVSS vector for backward compatibility
        if (data.metrics.length > 0) {
            const cvssV3 = data.metrics.find(m => m.metricType === 'cvssV3_1' || m.metricType === 'cvssV3_0')
            if (cvssV3) {
                data.vectorString = cvssV3.vectorString
            }
        }

        // Legacy: Extract affected products for backward compatibility
        if (data.affected.length > 0) {
            data.affectedVendor = data.affected[0].vendor
            data.affectedProduct = data.affected[0].product
            data.affectedVersions = data.affected.map(a => ({
                vendor: a.vendor,
                product: a.product,
                versions: a.versions
            }))
        }

        // Extract references from CNA container
        const cnaReferences = cveOrgData.containers?.cna?.references
        if (cnaReferences && Array.isArray(cnaReferences)) {
            data.references = cnaReferences
                .filter((ref: any) => ref?.url)
                .map((ref: any) => ({
                    url: ref.url,
                    type: ref.tags?.[0] || ref.name,
                    title: ref.name
                }))
            console.log(`[parseCVEOrgToCVE] Extracted ${data.references.length} references from CVE.org data for ${cveId}`)
        } else {
            console.log(`[parseCVEOrgToCVE] No references found in CVE.org data for ${cveId}`)
        }

        // Extract SSVC decisions from ADP containers (after references so we can use them for override)
        if (adpContainers && Array.isArray(adpContainers)) {
            const ssvcDecisions = extractSSVCFromADP(adpContainers, cveId, safeLogger, data.references)
            if (ssvcDecisions.length > 0) {
                data.ssvcDecisions = ssvcDecisions
                safeLogger.info(`[CVE Storage] Found ${ssvcDecisions.length} SSVC decision(s) in ADP for ${cveId}`);
            }
        }

        safeLogger.info(`[CVE Parser] Extracted for ${cveId}: ${data.problemTypes.length} problem types, ${data.metrics.length} metrics, ${data.affected.length} affected, ${data.descriptions.length} descriptions`);

        return data
    } catch (error) {
        return null
    }
}

/**
 * Parse CPE URI to extract vendor and product
 * CPE format: cpe:2.3:a:vendor:product:version:update:edition:language:sw_edition:target_sw:target_hw:other
 */
const parseCPEUri = (cpeUri: string): { vendor?: string; product?: string; version?: string } => {
    try {
        const parts = cpeUri.split(':')
        if (parts.length >= 5) {
            return {
                vendor: parts[3] !== '*' ? parts[3] : undefined,
                product: parts[4] !== '*' ? parts[4] : undefined,
                version: parts[5] !== '*' ? parts[5] : undefined
            }
        }
        return {}
    } catch (error) {
        return {}
    }
}

/**
 * Parse NIST NVD response to CVE data format with Anchore ADP enrichment
 * Handles the NIST NVD API v2.0 structure and merges Anchore ADP data
 * Merges CPE strings, references, version data, and affected products from both sources
 * Uses ADP dates when NVD dates are missing, otherwise keeps NVD dates
 */
export const parseNistNvdToCVE = (nvdData: any, adpData: any, logger?: any): CVESourceData | null => {
    try {
        // Validate that nvdData has the expected structure
        if (!nvdData || typeof nvdData !== 'object') {
            if (logger) {
                logger.error('[parseNistNvdToCVE] Invalid nvdData: expected object', {
                    type: typeof nvdData,
                    preview: JSON.stringify(nvdData).substring(0, 200)
                })
            }
            return null
        }

        const cve = nvdData?.cve

        // If nvdData doesn't have a cve property, it's likely a malformed extraction
        if (!cve) {
            if (logger) {
                logger.error('[parseNistNvdToCVE] Missing cve property in nvdData', {
                    keys: Object.keys(nvdData),
                    preview: JSON.stringify(nvdData).substring(0, 200)
                })
            }
            return null
        }

        const cveId = cve?.id || adpData?.additionalMetadata?.cveId

        if (!cveId) {
            if (logger) {
                logger.error('[parseNistNvdToCVE] No CVE ID found in NVD or ADP data')
            }
            return null
        }

        const data: CVESourceData = {
            cveId,
            source: 'nvd',
            dataVersion: '2.0',
            state: cve?.vulnStatus || 'PUBLISHED',
            // Use NVD dates if available, otherwise fall back to ADP dates
            datePublished: cve?.published
                ? Math.floor(new Date(cve.published).getTime() / 1000)
                : (adpData?.additionalMetadata?.upstream?.datePublished
                    ? Math.floor(new Date(adpData.additionalMetadata.upstream.datePublished).getTime() / 1000)
                    : undefined),
            dateUpdated: cve?.lastModified
                ? Math.floor(new Date(cve.lastModified).getTime() / 1000)
                : (adpData?.additionalMetadata?.upstream?.dateUpdated
                    ? Math.floor(new Date(adpData.additionalMetadata.upstream.dateUpdated).getTime() / 1000)
                    : undefined),
            dateReserved: adpData?.additionalMetadata?.upstream?.dateReserved
                ? Math.floor(new Date(adpData.additionalMetadata.upstream.dateReserved).getTime() / 1000)
                : undefined,
            title: cve?.descriptions?.[0]?.value?.substring(0, 100) || adpData?.additionalMetadata?.description?.substring(0, 100),
            sourceAdvisoryRef: cve?.references?.[0]?.url || adpData?.additionalMetadata?.references?.[0],
            rawData: { nvd: nvdData, adp: adpData },
            problemTypes: [],
            metrics: [],
            affected: [],
            descriptions: [],
            impacts: []
        }

        // Extract descriptions from NVD (multilingual support)
        if (cve?.descriptions && Array.isArray(cve.descriptions)) {
            for (const desc of cve.descriptions) {
                data.descriptions.push({
                    containerType: 'cna', // NIST NVD acts as authoritative source
                    lang: desc.lang || 'en',
                    value: desc.value
                })
            }
        }

        // Add ADP description if available and not already present
        if (adpData?.additionalMetadata?.description) {
            const adpDesc = adpData.additionalMetadata.description
            const alreadyExists = data.descriptions.some(d => d.value === adpDesc)
            if (!alreadyExists) {
                data.descriptions.push({
                    containerType: 'adp',
                    adpOrgId: adpData.adp?.providerMetadata?.shortName || 'anchore',
                    lang: 'en',
                    value: adpDesc
                })
            }
        }

        // Extract CVSS metrics from NVD (v2.0, v3.0, v3.1, v4.0)
        if (cve?.metrics) {
            // CVSS v2.0
            if (cve.metrics.cvssMetricV2 && Array.isArray(cve.metrics.cvssMetricV2)) {
                for (const metric of cve.metrics.cvssMetricV2) {
                    if (metric.cvssData) {
                        data.metrics.push({
                            containerType: 'cna',
                            metricType: 'cvssV2_0',
                            vectorString: metric.cvssData.vectorString,
                            baseScore: metric.cvssData.baseScore,
                            baseSeverity: metric.baseSeverity
                        })
                    }
                }
            }

            // CVSS v3.0
            if (cve.metrics.cvssMetricV30 && Array.isArray(cve.metrics.cvssMetricV30)) {
                for (const metric of cve.metrics.cvssMetricV30) {
                    if (metric.cvssData) {
                        data.metrics.push({
                            containerType: 'cna',
                            metricType: 'cvssV3_0',
                            vectorString: metric.cvssData.vectorString,
                            baseScore: metric.cvssData.baseScore,
                            baseSeverity: metric.cvssData.baseSeverity
                        })
                    }
                }
            }

            // CVSS v3.1
            if (cve.metrics.cvssMetricV31 && Array.isArray(cve.metrics.cvssMetricV31)) {
                for (const metric of cve.metrics.cvssMetricV31) {
                    if (metric.cvssData) {
                        data.metrics.push({
                            containerType: 'cna',
                            metricType: 'cvssV3_1',
                            vectorString: metric.cvssData.vectorString,
                            baseScore: metric.cvssData.baseScore,
                            baseSeverity: metric.cvssData.baseSeverity
                        })
                    }
                }
            }

            // CVSS v4.0
            if (cve.metrics.cvssMetricV40 && Array.isArray(cve.metrics.cvssMetricV40)) {
                for (const metric of cve.metrics.cvssMetricV40) {
                    if (metric.cvssData) {
                        data.metrics.push({
                            containerType: 'cna',
                            metricType: 'cvssV4_0',
                            vectorString: metric.cvssData.vectorString,
                            baseScore: metric.cvssData.baseScore,
                            baseSeverity: metric.cvssData.baseSeverity
                        })
                    }
                }
            }
        }

        // Extract weaknesses (CWE IDs) from NVD
        if (cve?.weaknesses && Array.isArray(cve.weaknesses)) {
            for (const weakness of cve.weaknesses) {
                if (weakness.description && Array.isArray(weakness.description)) {
                    for (const desc of weakness.description) {
                        // Extract CWE ID from value (format: "CWE-79", "CWE-89", etc.)
                        const cweMatch = desc.value?.match(/^(CWE-\d+)/)
                        data.problemTypes.push({
                            containerType: 'cna',
                            cweId: cweMatch ? cweMatch[1] : undefined,
                            description: desc.value,
                            descriptionType: cweMatch ? 'CWE' : 'text',
                            lang: desc.lang || 'en'
                        })
                    }
                }
            }
        }

        // Extract affected products from NVD CPE configurations
        if (cve?.configurations && Array.isArray(cve.configurations)) {
            const vendors = new Set<string>()
            const products = new Set<string>()
            const cpes: string[] = []

            for (const config of cve.configurations) {
                if (config.nodes && Array.isArray(config.nodes)) {
                    for (const node of config.nodes) {
                        if (node.cpeMatch && Array.isArray(node.cpeMatch)) {
                            for (const cpeMatch of node.cpeMatch) {
                                if (cpeMatch.vulnerable && cpeMatch.criteria) {
                                    cpes.push(cpeMatch.criteria)
                                    const parsed = parseCPEUri(cpeMatch.criteria)
                                    if (parsed.vendor) vendors.add(parsed.vendor)
                                    if (parsed.product) products.add(parsed.product)

                                    // Extract version range information
                                    const versions: CVEAffectedVersionData[] = []
                                    if (cpeMatch.versionStartIncluding || cpeMatch.versionStartExcluding ||
                                        cpeMatch.versionEndIncluding || cpeMatch.versionEndExcluding) {

                                        // Create a version range entry
                                        if (cpeMatch.versionStartIncluding) {
                                            versions.push({
                                                version: cpeMatch.versionStartIncluding,
                                                status: 'affected',
                                                versionType: 'semver',
                                                lessThanOrEqual: cpeMatch.versionEndIncluding,
                                                lessThan: cpeMatch.versionEndExcluding
                                            })
                                        } else if (cpeMatch.versionEndIncluding || cpeMatch.versionEndExcluding) {
                                            versions.push({
                                                version: '*',
                                                status: 'affected',
                                                versionType: 'semver',
                                                lessThanOrEqual: cpeMatch.versionEndIncluding,
                                                lessThan: cpeMatch.versionEndExcluding
                                            })
                                        }
                                    }

                                    // Only add affected entry if we have meaningful data
                                    if (parsed.vendor && parsed.product) {
                                        data.affected.push({
                                            containerType: 'cna',
                                            vendor: parsed.vendor,
                                            product: parsed.product,
                                            cpes: [cpeMatch.criteria],
                                            versions: versions.length > 0 ? versions : undefined
                                        })
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Set legacy fields for backward compatibility
            if (vendors.size > 0) {
                data.affectedVendor = Array.from(vendors)[0]
            }
            if (products.size > 0) {
                data.affectedProduct = Array.from(products)[0]
            }
            if (cpes.length > 0) {
                data.cpes = cpes
            }
        }

        // Merge ADP affected products and CPEs from Anchore
        if (adpData?.adp?.affected && Array.isArray(adpData.adp.affected)) {
            for (const affectedItem of adpData.adp.affected) {
                const versions: CVEAffectedVersionData[] = []

                // Extract version data from ADP
                if (affectedItem.versions && Array.isArray(affectedItem.versions)) {
                    for (const version of affectedItem.versions) {
                        versions.push({
                            version: version.version || '*',
                            status: version.status || 'affected',
                            versionType: version.versionType || 'semver',
                            lessThan: version.lessThan,
                            lessThanOrEqual: version.lessThanOrEqual
                        })
                    }
                }

                // Add affected product entry from ADP
                data.affected.push({
                    containerType: 'adp',
                    adpOrgId: adpData.adp.providerMetadata?.shortName || 'anchore',
                    vendor: affectedItem.vendor,
                    product: affectedItem.product || affectedItem.packageName,
                    packageName: affectedItem.packageName,
                    repo: affectedItem.repo,
                    collectionURL: affectedItem.collectionURL,
                    cpes: affectedItem.cpes,
                    versions: versions.length > 0 ? versions : undefined
                })

                // Merge ADP CPEs into main cpes array
                if (affectedItem.cpes && Array.isArray(affectedItem.cpes)) {
                    if (!data.cpes) {
                        data.cpes = []
                    }
                    for (const cpe of affectedItem.cpes) {
                        if (!data.cpes.includes(cpe)) {
                            data.cpes.push(cpe)
                        }
                    }
                }
            }

            if (logger) {
                logger.info(`[parseNistNvdToCVE] Merged ${adpData.adp.affected.length} affected product(s) from Anchore ADP for ${cveId}`)
            }
        }

        // Extract and merge references from NVD
        if (cve?.references && Array.isArray(cve.references)) {
            data.references = cve.references
                .filter((ref: any) => ref?.url)
                .map((ref: any) => ({
                    url: ref.url,
                    type: ref.tags?.[0] || 'MISC',
                    title: ref.source
                }))

            if (logger) {
                logger.info(`[parseNistNvdToCVE] Extracted ${data.references.length} references from NIST NVD data for ${cveId}`)
            }
        } else {
            data.references = []
        }

        // Merge ADP references from Anchore
        if (adpData?.additionalMetadata?.references && Array.isArray(adpData.additionalMetadata.references)) {
            const existingUrls = new Set(data.references.map(r => r.url))
            for (const refUrl of adpData.additionalMetadata.references) {
                if (!existingUrls.has(refUrl)) {
                    data.references.push({
                        url: refUrl,
                        type: 'ADVISORY',
                        title: 'Anchore ADP'
                    })
                    existingUrls.add(refUrl)
                }
            }

            if (logger) {
                logger.info(`[parseNistNvdToCVE] Merged ${adpData.additionalMetadata.references.length} reference(s) from Anchore ADP for ${cveId}`)
            }
        }

        // Set legacy vectorString for backward compatibility (prioritize CVSS v4.0 > v3.1 > v3.0 > v2.0 with conversion)
        if (data.metrics.length > 0) {
            const cvssV4 = data.metrics.find(m => m.metricType === 'cvssV4_0')
            const cvssV31 = data.metrics.find(m => m.metricType === 'cvssV3_1')
            const cvssV30 = data.metrics.find(m => m.metricType === 'cvssV3_0')
            const cvssV2 = data.metrics.find(m => m.metricType === 'cvssV2_0')

            if (cvssV4) {
                data.vectorString = cvssV4.vectorString
                if (logger) {
                    logger.info(`[parseNistNvdToCVE] Using CVSS v4.0 vector for ${cveId}: ${cvssV4.vectorString}`)
                }
            } else if (cvssV31) {
                data.vectorString = cvssV31.vectorString
                if (logger) {
                    logger.info(`[parseNistNvdToCVE] Using CVSS v3.1 vector for ${cveId}: ${cvssV31.vectorString}`)
                }
            } else if (cvssV30) {
                data.vectorString = cvssV30.vectorString
                if (logger) {
                    logger.info(`[parseNistNvdToCVE] Using CVSS v3.0 vector for ${cveId}: ${cvssV30.vectorString}`)
                }
            } else if (cvssV2) {
                // Convert CVSS v2.0 to v3.1 for legacy CVEs
                const convertedVector = convertCvssV2ToV31(cvssV2.vectorString)
                if (convertedVector) {
                    data.vectorString = convertedVector
                    if (logger) {
                        logger.info(`[parseNistNvdToCVE] Converted CVSS v2.0 to v3.1 for ${cveId}: ${cvssV2.vectorString} -> ${convertedVector}`)
                    }
                } else {
                    if (logger) {
                        logger.warn(`[parseNistNvdToCVE] Failed to convert CVSS v2.0 vector for ${cveId}: ${cvssV2.vectorString}`)
                    }
                }
            } else {
                if (logger) {
                    logger.warn(`[parseNistNvdToCVE] No CVSS v4.0, v3.1, v3.0, or v2.0 found for ${cveId}. Available metrics: ${data.metrics.map(m => m.metricType).join(', ')}`)
                }
            }
        } else {
            if (logger) {
                logger.warn(`[parseNistNvdToCVE] No metrics found for ${cveId}`)
            }
        }

        if (logger) {
            logger.info(`[parseNistNvdToCVE] Extracted for ${cveId}: ${data.problemTypes.length} problem types, ${data.metrics.length} metrics, ${data.affected.length} affected, ${data.descriptions.length} descriptions, ${data.references?.length || 0} references`)
        }

        return data
    } catch (error) {
        if (logger) {
            logger.error('[parseNistNvdToCVE] Parse error:', error)
        }
        return null
    }
}

/**
 * Parse CISA ADP (Vulnrichment) container from CVE.org data
 * Extracts CISA-specific ADP enrichment data as a separate CVE record
 * @param cveOrgData Full CVE.org record containing ADP containers
 * @param logger Logger instance
 * @returns CVE data with CISA ADP enrichments only, or null if no CISA ADP found
 */
export const parseCisaAdpToCVE = (cveOrgData: any, logger?: any): CVESourceData | null => {
    // Create a safe logger wrapper to prevent "is not a function" errors
    const safeLogger = {
        info: (msg: string, ...args: any[]) => {
            try { if (logger && typeof logger.info === 'function') logger.info(msg, ...args); } catch (e) { /* ignore */ }
        },
        debug: (msg: string, ...args: any[]) => {
            try { if (logger && typeof logger.debug === 'function') logger.debug(msg, ...args); } catch (e) { /* ignore */ }
        }
    };

    try {
        const cveId = cveOrgData.cveMetadata?.cveId

        // Look for CISA ADP container
        const adpContainers = cveOrgData.containers?.adp
        if (!adpContainers || !Array.isArray(adpContainers)) {
            safeLogger.debug(`[parseCisaAdpToCVE] No ADP containers found in CVE.org data for ${cveId}`);
            return null
        }

        // Find CISA ADP container by orgId
        const cisaAdpContainer = adpContainers.find((container: any) =>
            container.providerMetadata?.orgId === '134c704f-9b21-4f2e-91b3-4a467353bcc0'
        )

        if (!cisaAdpContainer) {
            safeLogger.debug(`[parseCisaAdpToCVE] No CISA ADP container found in CVE.org data for ${cveId}`);
            return null
        }

        safeLogger.info(`[parseCisaAdpToCVE] Found CISA ADP container for ${cveId}`);

        // Create CVE data structure with CISA ADP source
        const data: CVESourceData = {
            cveId,
            source: 'cisa_adp',
            dataVersion: cveOrgData.dataVersion || '5.0',
            state: cveOrgData.cveMetadata?.state || 'PUBLISHED',
            datePublished: cveOrgData.cveMetadata?.datePublished ? new Date(cveOrgData.cveMetadata.datePublished).getTime() / 1000 : undefined,
            dateUpdated: cisaAdpContainer.dateUpdated ? new Date(cisaAdpContainer.dateUpdated).getTime() / 1000 : undefined,
            dateReserved: cveOrgData.cveMetadata?.dateReserved ? new Date(cveOrgData.cveMetadata.dateReserved).getTime() / 1000 : undefined,
            title: cisaAdpContainer.title || cveOrgData.containers?.cna?.title,
            sourceAdvisoryRef: cisaAdpContainer.references?.[0]?.url,
            adpPublishers: [{
                orgId: cisaAdpContainer.providerMetadata?.orgId || '134c704f-9b21-4f2e-91b3-4a467353bcc0',
                shortName: cisaAdpContainer.providerMetadata?.shortName || 'CISA-ADP',
                title: 'Cybersecurity and Infrastructure Security Agency'
            }],
            rawData: { cveOrg: cveOrgData, cisaAdp: cisaAdpContainer },
            problemTypes: [],
            metrics: [],
            affected: [],
            descriptions: [],
            impacts: []
        }

        // First, extract base data from CNA container for completeness
        // This ensures CISA ADP records have the core CVE data (affected products, descriptions, etc.)
        const cnaContainer = cveOrgData.containers?.cna
        if (cnaContainer) {
            data.problemTypes.push(...extractProblemTypes(cnaContainer, 'cna'))
            data.metrics.push(...extractMetrics(cnaContainer, 'cna'))
            data.affected.push(...extractAffected(cnaContainer, 'cna'))
            data.descriptions.push(...extractDescriptions(cnaContainer, 'cna'))
            data.impacts.push(...extractImpacts(cnaContainer, 'cna'))

            safeLogger.info(`[parseCisaAdpToCVE] Merged CNA base data for ${cveId}: ${data.affected.length} affected from CNA`)
        }

        // Then, add/merge CISA ADP enrichments
        const adpOrgId = cisaAdpContainer.providerMetadata?.orgId || '134c704f-9b21-4f2e-91b3-4a467353bcc0'
        const adpProblemTypes = extractProblemTypes(cisaAdpContainer, 'adp', adpOrgId)
        const adpMetrics = extractMetrics(cisaAdpContainer, 'adp', adpOrgId)
        const adpAffected = extractAffected(cisaAdpContainer, 'adp', adpOrgId)
        const adpDescriptions = extractDescriptions(cisaAdpContainer, 'adp', adpOrgId)
        const adpImpacts = extractImpacts(cisaAdpContainer, 'adp', adpOrgId)

        data.problemTypes.push(...adpProblemTypes)
        data.metrics.push(...adpMetrics)
        data.affected.push(...adpAffected)
        data.descriptions.push(...adpDescriptions)
        data.impacts.push(...adpImpacts)

        safeLogger.info(`[parseCisaAdpToCVE] Added CISA ADP enrichments for ${cveId}: ${adpMetrics.length} metrics, ${adpImpacts.length} impacts from CISA`)

        // Extract references from CISA ADP (if any) - Do this BEFORE SSVC extraction
        // so we can use them for exploit detection
        if (cisaAdpContainer.references && Array.isArray(cisaAdpContainer.references)) {
            data.references = cisaAdpContainer.references
                .filter((ref: any) => ref?.url)
                .map((ref: any) => ({
                    url: ref.url,
                    type: ref.tags?.[0] || ref.name || 'ADVISORY',
                    title: ref.name
                }))
            safeLogger.info(`[parseCisaAdpToCVE] Extracted ${data.references.length} references from CISA ADP for ${cveId}`)
        } else if (cnaContainer?.references && Array.isArray(cnaContainer.references)) {
            // Fall back to CNA references if CISA ADP has none
            data.references = cnaContainer.references
                .filter((ref: any) => ref?.url)
                .map((ref: any) => ({
                    url: ref.url,
                    type: ref.tags?.[0] || 'MISC',
                    title: ref.name
                }))
        }

        // Extract SSVC decisions from CISA ADP container (after references so we can use them for override)
        const ssvcDecisions = extractSSVCFromADP([cisaAdpContainer], cveId, safeLogger, data.references)
        if (ssvcDecisions.length > 0) {
            data.ssvcDecisions = ssvcDecisions
            safeLogger.info(`[parseCisaAdpToCVE] Found ${ssvcDecisions.length} SSVC decision(s) in CISA ADP for ${cveId}`)
        }

        // Legacy: Set affectedVendor and affectedProduct for backward compatibility
        if (data.affected.length > 0) {
            data.affectedVendor = data.affected[0].vendor
            data.affectedProduct = data.affected[0].product
            data.affectedVersions = data.affected.map(a => ({
                vendor: a.vendor,
                product: a.product,
                versions: a.versions
            }))
        }

        // Legacy: Set vectorString for backward compatibility (prioritize CISA CVSS if available)
        if (data.metrics.length > 0) {
            const cvssV31 = data.metrics.find(m => m.metricType === 'cvssV3_1')
            const cvssV30 = data.metrics.find(m => m.metricType === 'cvssV3_0')
            if (cvssV31) {
                data.vectorString = cvssV31.vectorString
            } else if (cvssV30) {
                data.vectorString = cvssV30.vectorString
            }
        }

        safeLogger.info(`[parseCisaAdpToCVE] Final data for ${cveId}: ${data.problemTypes.length} problem types, ${data.metrics.length} metrics, ${data.affected.length} affected, ${data.descriptions.length} descriptions, ${data.impacts.length} impacts, ${data.references?.length || 0} references`)

        return data
    } catch (error) {
        if (logger) {
            logger.error('[parseCisaAdpToCVE] Parse error:', error)
        }
        return null
    }
}

/**
 * Parse Anchore ADP enrichment data merged with NVD base data
 * Creates a separate CVE record with source 'anchore_adp' that enriches NVD data
 * @param nvdData Base NVD vulnerability data (from parseNistNvdToCVE result)
 * @param adpData Anchore ADP enrichment data
 * @param logger Logger instance
 * @returns CVE data with Anchore ADP enrichments merged into NVD base
 */
export const parseAnchoreAdpToCVE = (nvdData: any, adpData: any, logger?: any): CVESourceData | null => {
    try {
        const cve = nvdData?.cve
        const cveId = cve?.id || adpData?.additionalMetadata?.cveId

        if (!cveId) {
            if (logger) {
                logger.error('[parseAnchoreAdpToCVE] No CVE ID found in NVD or ADP data')
            }
            return null
        }

        // Start with NVD data as base
        const data: CVESourceData = {
            cveId,
            source: 'anchore_adp', // Mark as Anchore ADP source
            dataVersion: '2.0',
            state: cve?.vulnStatus || 'PUBLISHED',
            // Use NVD dates if available, otherwise fall back to ADP dates
            datePublished: cve?.published
                ? Math.floor(new Date(cve.published).getTime() / 1000)
                : (adpData?.additionalMetadata?.upstream?.datePublished
                    ? Math.floor(new Date(adpData.additionalMetadata.upstream.datePublished).getTime() / 1000)
                    : undefined),
            dateUpdated: cve?.lastModified
                ? Math.floor(new Date(cve.lastModified).getTime() / 1000)
                : (adpData?.additionalMetadata?.upstream?.dateUpdated
                    ? Math.floor(new Date(adpData.additionalMetadata.upstream.dateUpdated).getTime() / 1000)
                    : undefined),
            dateReserved: adpData?.additionalMetadata?.upstream?.dateReserved
                ? Math.floor(new Date(adpData.additionalMetadata.upstream.dateReserved).getTime() / 1000)
                : undefined,
            title: cve?.descriptions?.[0]?.value?.substring(0, 100) || adpData?.additionalMetadata?.description?.substring(0, 100),
            sourceAdvisoryRef: adpData?.additionalMetadata?.references?.[0] || cve?.references?.[0]?.url,
            rawData: { nvd: nvdData, adp: adpData },
            problemTypes: [],
            metrics: [],
            affected: [],
            descriptions: [],
            impacts: []
        }

        // Extract descriptions from NVD (multilingual support)
        if (cve?.descriptions && Array.isArray(cve.descriptions)) {
            for (const desc of cve.descriptions) {
                data.descriptions.push({
                    containerType: 'cna', // NIST NVD acts as authoritative source
                    lang: desc.lang || 'en',
                    value: desc.value
                })
            }
        }

        // Add ADP description if available and not already present
        if (adpData?.additionalMetadata?.description) {
            const adpDesc = adpData.additionalMetadata.description
            const alreadyExists = data.descriptions.some(d => d.value === adpDesc)
            if (!alreadyExists) {
                data.descriptions.push({
                    containerType: 'adp',
                    adpOrgId: adpData.adp?.providerMetadata?.shortName || 'anchore',
                    lang: 'en',
                    value: adpDesc
                })
            }
        }

        // Extract CVSS metrics from NVD (v2.0, v3.0, v3.1, v4.0)
        if (cve?.metrics) {
            // CVSS v2.0
            if (cve.metrics.cvssMetricV2 && Array.isArray(cve.metrics.cvssMetricV2)) {
                for (const metric of cve.metrics.cvssMetricV2) {
                    if (metric.cvssData) {
                        data.metrics.push({
                            containerType: 'cna',
                            metricType: 'cvssV2_0',
                            vectorString: metric.cvssData.vectorString,
                            baseScore: metric.cvssData.baseScore,
                            baseSeverity: metric.baseSeverity
                        })
                    }
                }
            }
            // CVSS v3.0
            if (cve.metrics.cvssMetricV30 && Array.isArray(cve.metrics.cvssMetricV30)) {
                for (const metric of cve.metrics.cvssMetricV30) {
                    if (metric.cvssData) {
                        data.metrics.push({
                            containerType: 'cna',
                            metricType: 'cvssV3_0',
                            vectorString: metric.cvssData.vectorString,
                            baseScore: metric.cvssData.baseScore,
                            baseSeverity: metric.cvssData.baseSeverity
                        })
                    }
                }
            }
            // CVSS v3.1
            if (cve.metrics.cvssMetricV31 && Array.isArray(cve.metrics.cvssMetricV31)) {
                for (const metric of cve.metrics.cvssMetricV31) {
                    if (metric.cvssData) {
                        data.metrics.push({
                            containerType: 'cna',
                            metricType: 'cvssV3_1',
                            vectorString: metric.cvssData.vectorString,
                            baseScore: metric.cvssData.baseScore,
                            baseSeverity: metric.cvssData.baseSeverity
                        })
                    }
                }
            }
            // CVSS v4.0
            if (cve.metrics.cvssMetricV40 && Array.isArray(cve.metrics.cvssMetricV40)) {
                for (const metric of cve.metrics.cvssMetricV40) {
                    if (metric.cvssData) {
                        data.metrics.push({
                            containerType: 'cna',
                            metricType: 'cvssV4_0',
                            vectorString: metric.cvssData.vectorString,
                            baseScore: metric.cvssData.baseScore,
                            baseSeverity: metric.cvssData.baseSeverity
                        })
                    }
                }
            }
        }

        // Extract weaknesses (CWE IDs) from NVD
        if (cve?.weaknesses && Array.isArray(cve.weaknesses)) {
            for (const weakness of cve.weaknesses) {
                if (weakness.description && Array.isArray(weakness.description)) {
                    for (const desc of weakness.description) {
                        // Extract CWE ID from value (format: "CWE-79", "CWE-89", etc.)
                        const cweMatch = desc.value?.match(/^(CWE-\d+)/)
                        data.problemTypes.push({
                            containerType: 'cna',
                            cweId: cweMatch ? cweMatch[1] : undefined,
                            description: desc.value,
                            descriptionType: cweMatch ? 'CWE' : 'text',
                            lang: desc.lang || 'en'
                        })
                    }
                }
            }
        }

        // Extract affected products from NVD CPE configurations
        if (cve?.configurations && Array.isArray(cve.configurations)) {
            const vendors = new Set<string>()
            const products = new Set<string>()
            const cpes: string[] = []

            for (const config of cve.configurations) {
                if (config.nodes && Array.isArray(config.nodes)) {
                    for (const node of config.nodes) {
                        if (node.cpeMatch && Array.isArray(node.cpeMatch)) {
                            for (const cpeMatch of node.cpeMatch) {
                                if (cpeMatch.vulnerable && cpeMatch.criteria) {
                                    cpes.push(cpeMatch.criteria)
                                    const parsed = parseCPEUri(cpeMatch.criteria)
                                    if (parsed.vendor) vendors.add(parsed.vendor)
                                    if (parsed.product) products.add(parsed.product)

                                    // Extract version range information
                                    const versions: CVEAffectedVersionData[] = []
                                    if (cpeMatch.versionStartIncluding || cpeMatch.versionStartExcluding ||
                                        cpeMatch.versionEndIncluding || cpeMatch.versionEndExcluding) {
                                        if (cpeMatch.versionStartIncluding) {
                                            versions.push({
                                                version: cpeMatch.versionStartIncluding,
                                                status: 'affected',
                                                versionType: 'semver',
                                                lessThanOrEqual: cpeMatch.versionEndIncluding,
                                                lessThan: cpeMatch.versionEndExcluding
                                            })
                                        } else if (cpeMatch.versionEndIncluding || cpeMatch.versionEndExcluding) {
                                            versions.push({
                                                version: '*',
                                                status: 'affected',
                                                versionType: 'semver',
                                                lessThanOrEqual: cpeMatch.versionEndIncluding,
                                                lessThan: cpeMatch.versionEndExcluding
                                            })
                                        }
                                    }

                                    // Only add affected entry if we have meaningful data
                                    if (parsed.vendor && parsed.product) {
                                        data.affected.push({
                                            containerType: 'cna',
                                            vendor: parsed.vendor,
                                            product: parsed.product,
                                            cpes: [cpeMatch.criteria],
                                            versions: versions.length > 0 ? versions : undefined
                                        })
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Set legacy fields for backward compatibility
            if (vendors.size > 0) {
                data.affectedVendor = Array.from(vendors)[0]
            }
            if (products.size > 0) {
                data.affectedProduct = Array.from(products)[0]
            }
            if (cpes.length > 0) {
                data.cpes = cpes
            }
        }

        // Merge ADP affected products and CPEs from Anchore
        if (adpData?.adp?.affected && Array.isArray(adpData.adp.affected)) {
            for (const affectedItem of adpData.adp.affected) {
                const versions: CVEAffectedVersionData[] = []

                // Extract version data from ADP
                if (affectedItem.versions && Array.isArray(affectedItem.versions)) {
                    for (const version of affectedItem.versions) {
                        versions.push({
                            version: version.version || '*',
                            status: version.status || 'affected',
                            versionType: version.versionType || 'semver',
                            lessThan: version.lessThan,
                            lessThanOrEqual: version.lessThanOrEqual
                        })
                    }
                }

                // Add affected product entry from ADP
                data.affected.push({
                    containerType: 'adp',
                    adpOrgId: adpData.adp.providerMetadata?.shortName || 'anchore',
                    vendor: affectedItem.vendor,
                    product: affectedItem.product || affectedItem.packageName,
                    packageName: affectedItem.packageName,
                    repo: affectedItem.repo,
                    collectionURL: affectedItem.collectionURL,
                    cpes: affectedItem.cpes,
                    versions: versions.length > 0 ? versions : undefined
                })

                // Merge ADP CPEs into main cpes array
                if (affectedItem.cpes && Array.isArray(affectedItem.cpes)) {
                    if (!data.cpes) data.cpes = []
                    for (const cpe of affectedItem.cpes) {
                        if (!data.cpes.includes(cpe)) {
                            data.cpes.push(cpe)
                        }
                    }
                }
            }
        }

        // Extract and merge references from NVD
        if (cve?.references && Array.isArray(cve.references)) {
            data.references = cve.references
                .filter((ref: any) => ref?.url)
                .map((ref: any) => ({
                    url: ref.url,
                    type: ref.tags?.[0] || 'MISC',
                    title: ref.source
                }))

            if (logger) {
                logger.info(`[parseAnchoreAdpToCVE] Extracted ${data.references.length} references from NIST NVD data for ${cveId}`)
            }
        } else {
            data.references = []
        }

        // Merge ADP references from Anchore
        if (adpData?.additionalMetadata?.references && Array.isArray(adpData.additionalMetadata.references)) {
            const existingUrls = new Set(data.references.map(r => r.url))
            for (const refUrl of adpData.additionalMetadata.references) {
                if (!existingUrls.has(refUrl)) {
                    data.references.push({
                        url: refUrl,
                        type: 'ADVISORY',
                        title: 'Anchore ADP'
                    })
                    existingUrls.add(refUrl)
                }
            }

            if (logger) {
                logger.info(`[parseAnchoreAdpToCVE] Merged ${adpData.additionalMetadata.references.length} reference(s) from Anchore ADP for ${cveId}`)
            }
        }

        // Set legacy vectorString for backward compatibility (prioritize CVSS v4.0 > v3.1 > v3.0 > v2.0 with conversion)
        if (data.metrics.length > 0) {
            const cvssV4 = data.metrics.find(m => m.metricType === 'cvssV4_0')
            const cvssV31 = data.metrics.find(m => m.metricType === 'cvssV3_1')
            const cvssV30 = data.metrics.find(m => m.metricType === 'cvssV3_0')
            const cvssV2 = data.metrics.find(m => m.metricType === 'cvssV2_0')

            if (cvssV4) {
                data.vectorString = cvssV4.vectorString
                if (logger) {
                    logger.info(`[parseAnchoreAdpToCVE] Using CVSS v4.0 vector for ${cveId}: ${cvssV4.vectorString}`)
                }
            } else if (cvssV31) {
                data.vectorString = cvssV31.vectorString
                if (logger) {
                    logger.info(`[parseAnchoreAdpToCVE] Using CVSS v3.1 vector for ${cveId}: ${cvssV31.vectorString}`)
                }
            } else if (cvssV30) {
                data.vectorString = cvssV30.vectorString
                if (logger) {
                    logger.info(`[parseAnchoreAdpToCVE] Using CVSS v3.0 vector for ${cveId}: ${cvssV30.vectorString}`)
                }
            } else if (cvssV2) {
                // Convert CVSS v2.0 to v3.1 for legacy CVEs
                const convertedVector = convertCvssV2ToV31(cvssV2.vectorString)
                if (convertedVector) {
                    data.vectorString = convertedVector
                    if (logger) {
                        logger.info(`[parseAnchoreAdpToCVE] Converted CVSS v2.0 to v3.1 for ${cveId}: ${cvssV2.vectorString} -> ${convertedVector}`)
                    }
                } else {
                    if (logger) {
                        logger.warn(`[parseAnchoreAdpToCVE] Failed to convert CVSS v2.0 vector for ${cveId}: ${cvssV2.vectorString}`)
                    }
                }
            } else {
                if (logger) {
                    logger.warn(`[parseAnchoreAdpToCVE] No CVSS v4.0, v3.1, v3.0, or v2.0 found for ${cveId}. Available metrics: ${data.metrics.map(m => m.metricType).join(', ')}`)
                }
            }
        } else {
            if (logger) {
                logger.warn(`[parseAnchoreAdpToCVE] No metrics found for ${cveId}`)
            }
        }

        if (logger) {
            logger.info(`[parseAnchoreAdpToCVE] Extracted for ${cveId}: ${data.problemTypes.length} problem types, ${data.metrics.length} metrics, ${data.affected.length} affected, ${data.descriptions.length} descriptions, ${data.references?.length || 0} references`)
        }

        return data
    } catch (error) {
        if (logger) {
            logger.error('[parseAnchoreAdpToCVE] Parse error:', error)
        }
        return null
    }
}

/**
 * Store CVE Problem Types (CWE and other classifications)
 */
export const storeCVEProblemTypes = async (
    prisma: PrismaClient,
    cveId: string,
    source: string,
    problemTypes: CVEProblemTypeData[],
    logger: Logger
): Promise<void> => {
    if (!problemTypes || problemTypes.length === 0) {
        return
    }

    const now = Math.floor(Date.now() / 1000)
    let created = 0
    let updated = 0

    try {
        // Update or create problem type records without deleting existing data
        for (const problemType of problemTypes) {
            // Try to find existing record with matching key fields
            const existing = await prisma.cVEProblemType.findFirst({
                where: {
                    cveId,
                    source,
                    containerType: problemType.containerType,
                    adpOrgId: problemType.adpOrgId || null,
                    cweId: problemType.cweId || null,
                    description: problemType.description
                }
            })

            if (existing) {
                // Update if fields differ
                const needsUpdate =
                    existing.descriptionType !== (problemType.descriptionType || 'text') ||
                    existing.lang !== (problemType.lang || 'en')

                if (needsUpdate) {
                    await prisma.cVEProblemType.update({
                        where: { uuid: existing.uuid },
                        data: {
                            descriptionType: problemType.descriptionType || 'text',
                            lang: problemType.lang || 'en'
                        }
                    })
                    updated++
                }
            } else {
                // Create new record
                await prisma.cVEProblemType.create({
                    data: {
                        cveId,
                        source,
                        containerType: problemType.containerType,
                        adpOrgId: problemType.adpOrgId,
                        cweId: problemType.cweId,
                        description: problemType.description,
                        descriptionType: problemType.descriptionType || 'text',
                        lang: problemType.lang || 'en',
                        createdAt: now
                    }
                })
                created++
            }
        }

        logger.info(`[CVE Storage] Problem types for ${cveId} from ${source}: ${created} created, ${updated} updated`)
    } catch (error) {
        logger.error(`[CVE Storage] Failed to store problem types for ${cveId}`, { error })
        throw error
    }
}

/**
 * Store CVE Metrics (CVSS and other scoring systems)
 */
export const storeCVEMetrics = async (
    prisma: PrismaClient,
    cveId: string,
    source: string,
    metrics: CVEMetricData[],
    logger: Logger
): Promise<void> => {
    if (!metrics || metrics.length === 0) {
        return
    }

    const now = Math.floor(Date.now() / 1000)
    let created = 0
    let updated = 0

    try {
        // Verify parent CVEMetadata record exists before creating child records
        const parentExists = await prisma.cVEMetadata.findUnique({
            where: {
                cveId_source: {
                    cveId,
                    source
                }
            }
        })

        if (!parentExists) {
            const error = new Error(`Cannot store CVEMetric: Parent CVEMetadata record does not exist for cveId=${cveId}, source=${source}`)
            logger.error(`[CVE Storage] ${error.message}`)
            throw error
        }

        // Update or create metric records without deleting existing data
        for (const metric of metrics) {
            // Try to find existing record with matching key fields
            const existing = await prisma.cVEMetric.findFirst({
                where: {
                    cveId,
                    source,
                    containerType: metric.containerType,
                    adpOrgId: metric.adpOrgId || null,
                    metricType: metric.metricType,
                    vectorString: metric.vectorString || null
                }
            })

            if (existing) {
                // Update if fields differ
                const needsUpdate =
                    existing.baseScore !== metric.baseScore ||
                    existing.baseSeverity !== metric.baseSeverity ||
                    existing.metricFormat !== metric.metricFormat ||
                    existing.scenariosJSON !== (metric.scenarios ? JSON.stringify(metric.scenarios) : null) ||
                    existing.otherType !== metric.otherType ||
                    existing.otherContent !== (metric.otherContent ? JSON.stringify(metric.otherContent) : null)

                if (needsUpdate) {
                    await prisma.cVEMetric.update({
                        where: { uuid: existing.uuid },
                        data: {
                            baseScore: metric.baseScore,
                            baseSeverity: metric.baseSeverity,
                            metricFormat: metric.metricFormat,
                            scenariosJSON: metric.scenarios ? JSON.stringify(metric.scenarios) : null,
                            otherType: metric.otherType,
                            otherContent: metric.otherContent ? JSON.stringify(metric.otherContent) : null
                        }
                    })
                    updated++
                }
            } else {
                // Create new metric record
                await prisma.cVEMetric.create({
                    data: {
                        cveId,
                        source,
                        containerType: metric.containerType,
                        adpOrgId: metric.adpOrgId,
                        metricType: metric.metricType,
                        vectorString: metric.vectorString,
                        baseScore: metric.baseScore,
                        baseSeverity: metric.baseSeverity,
                        metricFormat: metric.metricFormat,
                        scenariosJSON: metric.scenarios ? JSON.stringify(metric.scenarios) : null,
                        otherType: metric.otherType,
                        otherContent: metric.otherContent ? JSON.stringify(metric.otherContent) : null,
                        createdAt: now
                    }
                })
                created++
            }
        }

        logger.info(`[CVE Storage] Metrics for ${cveId} from ${source}: ${created} created, ${updated} updated`)
    } catch (error) {
        logger.error(`[CVE Storage] Failed to store metrics for ${cveId} from ${source}`, { error })
        throw error
    }
}

/**
 * Store CVE Affected Products and Versions
 */
export const storeCVEAffected = async (
    prisma: PrismaClient,
    cveId: string,
    source: string,
    affected: CVEAffectedData[],
    logger: Logger
): Promise<void> => {
    if (!affected || affected.length === 0) {
        return
    }

    const now = Math.floor(Date.now() / 1000)
    let created = 0
    let updated = 0
    let versionsCreated = 0
    let versionsUpdated = 0

    try {
        // Import URL categorizer for filtering exploit repos
        const { categorizeURL } = await import('@/services/utilities/url-categorizer')
        // Import hash calculator for unique constraint
        const { calculateAffectedHash } = await import('@/shared/utils/cve-affected-hash')

        // Update or create affected records without deleting existing data
        for (const affectedItem of affected) {
            // CRITICAL: Filter out exploit/PoC repositories from affected data
            // If the repo field points to an exploit repository (e.g., nuclei-templates),
            // we should NOT store it as affected software
            if (affectedItem.repo) {
                const categorized = categorizeURL(affectedItem.repo)
                if (categorized.category.type === 'exploit' || categorized.category.type === 'poc') {
                    logger.warn(`[CVE Storage] Skipping affected item with exploit/poc repo: ${affectedItem.repo}`)
                    continue // Skip this affected item entirely
                }
            }

            // Calculate hash for this affected item
            const affectedHash = calculateAffectedHash(
                affectedItem.vendor,
                affectedItem.product,
                affectedItem.collectionURL,
                affectedItem.packageName
            )

            // Try to find existing affected record using the hash
            const existing = await prisma.cVEAffected.findFirst({
                where: {
                    cveId,
                    source,
                    containerType: affectedItem.containerType,
                    affectedHash
                }
            })

            let affectedRecordUuid: string

            if (existing) {
                // Update if fields differ
                const needsUpdate =
                    existing.collectionURL !== affectedItem.collectionURL ||
                    existing.cpes !== (affectedItem.cpes ? JSON.stringify(affectedItem.cpes) : null) ||
                    existing.modules !== (affectedItem.modules ? JSON.stringify(affectedItem.modules) : null) ||
                    existing.programFiles !== (affectedItem.programFiles ? JSON.stringify(affectedItem.programFiles) : null) ||
                    existing.programRoutines !== (affectedItem.programRoutines ? JSON.stringify(affectedItem.programRoutines) : null) ||
                    existing.platforms !== (affectedItem.platforms ? JSON.stringify(affectedItem.platforms) : null) ||
                    existing.repo !== affectedItem.repo ||
                    existing.defaultStatus !== affectedItem.defaultStatus

                if (needsUpdate) {
                    await prisma.cVEAffected.update({
                        where: { uuid: existing.uuid },
                        data: {
                            collectionURL: affectedItem.collectionURL,
                            cpes: affectedItem.cpes ? JSON.stringify(affectedItem.cpes) : null,
                            modules: affectedItem.modules ? JSON.stringify(affectedItem.modules) : null,
                            programFiles: affectedItem.programFiles ? JSON.stringify(affectedItem.programFiles) : null,
                            programRoutines: affectedItem.programRoutines ? JSON.stringify(affectedItem.programRoutines) : null,
                            platforms: affectedItem.platforms ? JSON.stringify(affectedItem.platforms) : null,
                            repo: affectedItem.repo,
                            defaultStatus: affectedItem.defaultStatus
                        }
                    })
                    updated++
                }
                affectedRecordUuid = existing.uuid
            } else {
                // Create new affected record
                const affectedRecord = await prisma.cVEAffected.create({
                    data: {
                        cveId,
                        source,
                        containerType: affectedItem.containerType,
                        adpOrgId: affectedItem.adpOrgId,
                        vendor: affectedItem.vendor,
                        product: affectedItem.product,
                        collectionURL: affectedItem.collectionURL,
                        packageName: affectedItem.packageName,
                        affectedHash,
                        cpes: affectedItem.cpes ? JSON.stringify(affectedItem.cpes) : null,
                        modules: affectedItem.modules ? JSON.stringify(affectedItem.modules) : null,
                        programFiles: affectedItem.programFiles ? JSON.stringify(affectedItem.programFiles) : null,
                        programRoutines: affectedItem.programRoutines ? JSON.stringify(affectedItem.programRoutines) : null,
                        platforms: affectedItem.platforms ? JSON.stringify(affectedItem.platforms) : null,
                        repo: affectedItem.repo,
                        defaultStatus: affectedItem.defaultStatus,
                        createdAt: now
                    }
                })
                affectedRecordUuid = affectedRecord.uuid
                created++
            }

            // Handle version records if provided
            if (affectedItem.versions && affectedItem.versions.length > 0) {
                for (const version of affectedItem.versions) {
                    // Try to find existing version record
                    const existingVersion = await prisma.cVEAffectedVersion.findFirst({
                        where: {
                            affectedId: affectedRecordUuid,
                            version: version.version,
                            status: version.status
                        }
                    })

                    if (existingVersion) {
                        // Update if fields differ
                        const needsVersionUpdate =
                            existingVersion.versionType !== version.versionType ||
                            existingVersion.lessThan !== version.lessThan ||
                            existingVersion.lessThanOrEqual !== version.lessThanOrEqual ||
                            existingVersion.changes !== (version.changes ? JSON.stringify(version.changes) : null)

                        if (needsVersionUpdate) {
                            await prisma.cVEAffectedVersion.update({
                                where: { uuid: existingVersion.uuid },
                                data: {
                                    versionType: version.versionType,
                                    lessThan: version.lessThan,
                                    lessThanOrEqual: version.lessThanOrEqual,
                                    changes: version.changes ? JSON.stringify(version.changes) : null
                                }
                            })
                            versionsUpdated++
                        }
                    } else {
                        // Create new version record
                        await prisma.cVEAffectedVersion.create({
                            data: {
                                affectedId: affectedRecordUuid,
                                version: version.version,
                                status: version.status,
                                versionType: version.versionType,
                                lessThan: version.lessThan,
                                lessThanOrEqual: version.lessThanOrEqual,
                                changes: version.changes ? JSON.stringify(version.changes) : null,
                                createdAt: now
                            }
                        })
                        versionsCreated++
                    }
                }
            }
        }

        logger.info(`[CVE Storage] Affected for ${cveId} from ${source}: ${created} created, ${updated} updated, ${versionsCreated} versions created, ${versionsUpdated} versions updated`)
    } catch (error) {
        logger.error(`[CVE Storage] Failed to store affected products for ${cveId}`, { error })
        throw error
    }
}

/**
 * Store CVE Descriptions (multi-language support)
 */
export const storeCVEDescriptions = async (
    prisma: PrismaClient,
    cveId: string,
    source: string,
    descriptions: CVEDescriptionData[],
    logger: Logger
): Promise<void> => {
    if (!descriptions || descriptions.length === 0) {
        return
    }

    const now = Math.floor(Date.now() / 1000)
    let created = 0
    let updated = 0

    try {
        // Update or create description records without deleting existing data
        for (const description of descriptions) {
            // Try to find existing record with matching key fields
            const existing = await prisma.cVEDescription.findFirst({
                where: {
                    cveId,
                    source,
                    containerType: description.containerType,
                    adpOrgId: description.adpOrgId || null,
                    lang: description.lang || 'en',
                    value: description.value
                }
            })

            if (existing) {
                // Update if supporting media differs
                const needsUpdate =
                    existing.supportingMedia !== (description.supportingMedia ? JSON.stringify(description.supportingMedia) : null)

                if (needsUpdate) {
                    await prisma.cVEDescription.update({
                        where: { uuid: existing.uuid },
                        data: {
                            supportingMedia: description.supportingMedia ? JSON.stringify(description.supportingMedia) : null
                        }
                    })
                    updated++
                }
            } else {
                // Create new description record
                await prisma.cVEDescription.create({
                    data: {
                        cveId,
                        source,
                        containerType: description.containerType,
                        adpOrgId: description.adpOrgId,
                        lang: description.lang || 'en',
                        value: description.value,
                        supportingMedia: description.supportingMedia ? JSON.stringify(description.supportingMedia) : null,
                        createdAt: now
                    }
                })
                created++
            }
        }

        logger.info(`[CVE Storage] Descriptions for ${cveId} from ${source}: ${created} created, ${updated} updated`)
    } catch (error) {
        logger.error(`[CVE Storage] Failed to store descriptions for ${cveId}`, { error })
        throw error
    }
}

/**
 * Validates CAPEC ID format according to CVE Record Format specification
 * Pattern: CAPEC-[1-9][0-9]{0,4} (CAPEC-1 through CAPEC-99999)
 */
const isValidCapecId = (capecId: string): boolean => {
    return /^CAPEC-[1-9][0-9]{0,4}$/.test(capecId)
}

/**
 * Store CVE Impacts from CVEListV5 format
 * Extracts CAPEC-based impact scenarios from CNA or ADP containers
 *
 * @param prisma - Prisma client instance
 * @param cveId - CVE identifier (e.g., "CVE-2024-1234")
 * @param source - Data source (e.g., "cve.org", "nvd", "anchore_adp")
 * @param containerType - Container type: "cna" or "adp"
 * @param impactsData - Array of impact objects from CVE JSON
 * @param adpOrgId - ADP organization ID (null for CNA impacts)
 * @param logger - Logger instance
 */
export const storeCVEImpacts = async (
    prisma: PrismaClient,
    cveId: string,
    source: string,
    containerType: 'cna' | 'adp',
    impactsData: any[],
    adpOrgId: string | null,
    logger: Logger
): Promise<void> => {
    if (!impactsData || !Array.isArray(impactsData) || impactsData.length === 0) {
        logger.debug(`[CVE Storage] No impacts data provided for ${cveId}`)
        return
    }

    const now = Math.floor(Date.now() / 1000)
    let storedCount = 0
    let skippedCount = 0

    try {
        for (const impactData of impactsData) {
            // Validate impact data structure
            if (!impactData.descriptions || !Array.isArray(impactData.descriptions) || impactData.descriptions.length === 0) {
                logger.warn(`[CVE Storage] Impact missing required descriptions for ${cveId}`, { cveId, containerType })
                skippedCount++
                continue
            }

            // Extract and validate CAPEC ID (optional)
            const capecId = impactData.capecId || null
            if (capecId && !isValidCapecId(capecId)) {
                logger.warn(`[CVE Storage] Invalid CAPEC ID format: ${capecId} for ${cveId}`, { cveId, capecId })
                // Continue processing - store impact even if CAPEC ID is invalid
            }

            // Check for duplicate impact (same cveId, source, containerType, capecId)
            const existingImpact = await prisma.cVEImpact.findFirst({
                where: {
                    cveId,
                    source,
                    containerType,
                    capecId: capecId || null
                }
            })

            if (existingImpact) {
                logger.debug(`[CVE Storage] Impact already exists for ${cveId} with CAPEC ${capecId || 'none'}`, { cveId, capecId })
                skippedCount++
                continue
            }

            // Create CVEImpact record
            const impact = await prisma.cVEImpact.create({
                data: {
                    cveId,
                    source,
                    containerType,
                    adpOrgId,
                    capecId,
                    createdAt: now
                }
            })

            // Store multi-language descriptions
            let descriptionsStored = 0
            for (const desc of impactData.descriptions) {
                if (!desc.value || !desc.lang) {
                    logger.warn(`[CVE Storage] Invalid description format for impact ${impact.uuid}`, { cveId, impactUuid: impact.uuid })
                    continue
                }

                await prisma.cVEImpactDescription.create({
                    data: {
                        impactId: impact.uuid,
                        lang: desc.lang,
                        value: desc.value.substring(0, 4096), // Enforce max length from schema
                        createdAt: now
                    }
                })
                descriptionsStored++
            }

            storedCount++
            logger.debug(`[CVE Storage] Stored impact for ${cveId}`, {
                cveId,
                source,
                containerType,
                capecId,
                descriptionCount: descriptionsStored
            })
        }

        if (storedCount > 0) {
            logger.info(`[CVE Storage] Impacts for ${cveId} from ${containerType} container: ${storedCount} created (${skippedCount} duplicates skipped)`)
        }
    } catch (error) {
        logger.error(`[CVE Storage] Failed to store impacts for ${cveId}`, { error })
        throw error
    }
}
