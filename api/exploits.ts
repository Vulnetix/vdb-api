/**
 * Exploits API
 * Returns enriched exploit records for a given vulnerability identifier
 */
import type { PrismaClient } from '@prisma/client'
import type { HonoEnv } from '@worker'
import { Hono } from 'hono'
import { getExploitDBRawPath, getMetasploitModulePath, retrieveExternalFileFromR2 } from '@shared/vdb-identifier'

const app = new Hono<HonoEnv>()

/**
 * Check if a string matches exploit-related keywords (case insensitive, handle plurals)
 */
function isExploitRelated(text: string | null): boolean {
    if (!text) return false
    const normalized = text.toLowerCase()

    // Match: exploit, exploits, poc, pocs, sighting, sightings, weaponize, weaponized, attack
    const patterns = [
        'exploit',
        'poc',
        'proof of concept',
        'proof-of-concept',
        'sighting',
        'weaponiz', // matches weaponize, weaponized, weaponization
        'attack',
        'malware',
        'in-the-wild',
        'in the wild'
    ]

    return patterns.some(pattern => normalized.includes(pattern))
}

/**
 * Build enriched exploit record from CVEMetadataReferences
 */
async function buildExploitRecord(ref: any, r2adapter: any, logger: any): Promise<any> {
    const record: any = {
        uuid: ref.uuid,
        cveId: ref.cveId,
        source: ref.source,
        url: ref.url,
        type: ref.type,
        referenceSource: ref.referenceSource,
        title: ref.title,
        createdAt: ref.createdAt,
        httpStatus: ref.httpStatus,
        deadLink: ref.deadLink
    }

    // ExploitDB enrichment
    if (ref.exploitDbId) {
        record.exploitDb = {
            id: ref.exploitDbId,
            author: ref.exploitDbAuthor,
            date: ref.exploitDbDate,
            platform: ref.exploitDbPlatform,
            type: ref.exploitDbType,
            port: ref.exploitDbPort,
            verified: ref.exploitDbVerified === 1,
            rawUrl: `https://www.exploit-db.com/raw/${ref.exploitDbId}`
        }

        // Try to fetch raw content from R2
        if (r2adapter) {
            try {
                const r2Path = getExploitDBRawPath(ref.exploitDbId)
                const content = await retrieveExternalFileFromR2(r2adapter, r2Path, logger)
                if (content) {
                    record.exploitDb.rawContent = content
                    record.exploitDb.r2Path = r2Path
                }
            } catch (error) {
                logger.debug(`Failed to retrieve ExploitDB raw content from R2: ${error}`)
            }
        }
    }

    // Metasploit enrichment
    if (ref.referenceSource?.toLowerCase().includes('metasploit') || ref.url?.includes('/modules/exploits/')) {
        const modulePathMatch = ref.url?.match(/(\/modules\/exploits\/[^"'\s]+\.rb)/)
        if (modulePathMatch) {
            const modulePath = modulePathMatch[1]
            record.metasploit = {
                modulePath,
                moduleUrl: `https://github.com/rapid7/metasploit-framework/blob/master${modulePath}`,
                rawUrl: `https://raw.githubusercontent.com/rapid7/metasploit-framework/master${modulePath}`
            }

            // Try to fetch module content from R2
            if (r2adapter) {
                try {
                    const r2Path = getMetasploitModulePath(modulePath)
                    const content = await retrieveExternalFileFromR2(r2adapter, r2Path, logger)
                    if (content) {
                        record.metasploit.moduleContent = content
                        record.metasploit.r2Path = r2Path
                    }
                } catch (error) {
                    logger.debug(`Failed to retrieve Metasploit module from R2: ${error}`)
                }
            }
        }
    }

    // Nuclei template enrichment
    if (ref.nucleiPath) {
        record.nuclei = {
            path: ref.nucleiPath,
            commitSha: ref.commitSha,
            commitAuthorName: ref.commitAuthorName,
            commitCommitterName: ref.commitCommitterName,
            commitCommitterEmail: ref.commitCommitterEmail,
            commitMessage: ref.commitMessage,
            commentCount: ref.commentCount,
            templateUrl: `https://github.com/projectdiscovery/nuclei-templates/blob/main${ref.nucleiPath}`,
            rawUrl: `https://raw.githubusercontent.com/projectdiscovery/nuclei-templates/main${ref.nucleiPath}`
        }
    }

    // VulnerabilityLab enrichment
    if (ref.vlId) {
        record.vulnerabilityLab = {
            id: ref.vlId,
            title: ref.vlTitle,
            createdAt: ref.vlCreatedAt,
            updatedAt: ref.vlUpdatedAt,
            exploitationTechnique: ref.vlExploitationTechnique,
            authenticationType: ref.vlAuthenticationType,
            userInteraction: ref.vlUserInteraction,
            author: ref.vlAuthor,
            url: `https://www.vulnerability-lab.com/get_content.php?id=${ref.vlId}`
        }
    }

    // GitHub PR enrichment
    if (ref.prDiffUrl) {
        record.githubPR = {
            diffUrl: ref.prDiffUrl,
            state: ref.prState,
            author: ref.prAuthor,
            labels: ref.prLabels,
            mergedAt: ref.prMergedAt,
            mergeCommitSha: ref.prMergeCommitSha,
            health: ref.prRepoHealth
        }
    }

    // GitHub Commit enrichment
    if (ref.commitAuthorEmail) {
        record.githubCommit = {
            authorEmail: ref.commitAuthorEmail,
            authorLogin: ref.commitAuthorLogin,
            verified: ref.commitVerified === 1,
            health: ref.commitHealth
        }
    }

    // GitHub Gist enrichment
    if (ref.gistId) {
        record.githubGist = {
            id: ref.gistId,
            public: ref.gistPublic === 1,
            filesCount: ref.gistFilesCount,
            files: ref.gistFiles,
            comments: ref.gistComments,
            updatedAt: ref.gistUpdatedAt,
            url: `https://gist.github.com/${ref.gistId}`
        }
    }

    return record
}

/**
 * GET /exploits/:identifier
 * Returns an array of enriched exploit records for the given vulnerability identifier
 */
app.get('/:identifier', async (c) => {
    const prisma: PrismaClient = c.get('prisma')
    const logger = c.get('logger')
    const identifier = c.req.param('identifier')
    const r2adapter = c.env.r2artifacts

    if (!identifier) {
        return c.json({ error: 'Missing vulnerability identifier' }, 400)
    }

    try {
        const startTime = Date.now()

        // Normalize identifier to uppercase
        let vulnId = identifier.trim().toUpperCase()

        // Normalize GHSA to lowercase
        if (vulnId.startsWith('GHSA-')) {
            vulnId = `GHSA-${vulnId.slice(5).toLowerCase()}`
        }

        // Query all references for this vulnerability
        const allReferences = await prisma.cVEMetadataReferences.findMany({
            where: { cveId: vulnId }
        })

        // Filter for exploit-related references
        const exploitReferences = allReferences.filter(ref => {
            // Include if it has ExploitDB data
            if (ref.exploitDbId) return true

            // Include if it has Nuclei template data
            if (ref.nucleiPath) return true

            // Include if it has VulnerabilityLab data
            if (ref.vlId) return true

            // Include if it's a Metasploit reference
            if (ref.referenceSource?.toLowerCase().includes('metasploit')) return true
            if (ref.url?.includes('/modules/exploits/')) return true

            // Include if type or title contains exploit-related keywords
            if (isExploitRelated(ref.type)) return true
            if (isExploitRelated(ref.title)) return true
            if (isExploitRelated(ref.referenceSource)) return true

            return false
        })

        // Query VulnCheckXDB records via KEV
        const vulnCheckXDB = await prisma.vulnCheckXDB.findMany({
            where: {
                kev: {
                    cves: {
                        some: {
                            cveId: vulnId
                        }
                    }
                }
            },
            include: {
                kev: {
                    include: {
                        cves: {
                            where: {
                                cveId: vulnId
                            }
                        }
                    }
                }
            }
        })

        // Query CrowdSec sightings
        const crowdSecSightings = await prisma.crowdSecSighting.findMany({
            where: {
                cveId: vulnId
            },
            include: {
                crowdSecLog: true
            },
            orderBy: {
                firstSeen: 'desc'
            },
            take: 100 // Limit to most recent 100 sightings
        })

        // Build enriched exploit records
        const exploits: any[] = []

        // Add reference-based exploits
        for (const ref of exploitReferences) {
            const exploit = await buildExploitRecord(ref, r2adapter, logger)
            exploits.push(exploit)
        }

        // Add VulnCheckXDB exploits
        for (const xdb of vulnCheckXDB) {
            exploits.push({
                uuid: xdb.uuid,
                cveId: vulnId,
                source: 'vulncheck-xdb',
                type: 'exploit',
                vulnCheckXDB: {
                    id: xdb.xdbId,
                    url: xdb.xdbUrl,
                    dateAdded: xdb.dateAdded,
                    exploitType: xdb.exploitType,
                    cloneSshUrl: xdb.cloneSshUrl,
                    kevId: xdb.kev.id
                }
            })
        }

        // Add CrowdSec sightings
        for (const sighting of crowdSecSightings) {
            exploits.push({
                uuid: sighting.uuid,
                cveId: vulnId,
                source: 'crowdsec',
                type: 'sighting',
                crowdSec: {
                    ip: sighting.ip,
                    reputation: sighting.reputation,
                    confidence: sighting.confidence,
                    backgroundNoiseScore: sighting.backgroundNoiseScore,
                    firstSeen: sighting.firstSeen,
                    lastSeen: sighting.lastSeen,
                    asName: sighting.asName,
                    asNum: sighting.asNum,
                    country: sighting.locationCountry,
                    city: sighting.locationCity,
                    latitude: sighting.locationLat,
                    longitude: sighting.locationLon,
                    behaviors: sighting.behaviorsCsv?.split(',').map(b => b.trim()).filter(b => b) || [],
                    attackDetails: sighting.attackDetailsCsv?.split(',').map(a => a.trim()).filter(a => a) || [],
                    mitreTechniques: sighting.mitreTechniquesCsv?.split(',').map(t => t.trim()).filter(t => t) || [],
                    reverseDns: sighting.reverseDns,
                    targetCountries: sighting.targetCountriesJSON
                }
            })
        }

        // Sort exploits by date (most recent first)
        exploits.sort((a, b) => {
            const aDate = a.createdAt || a.exploitDb?.date || a.vulnerabilityLab?.createdAt ||
                         a.crowdSec?.firstSeen || a.vulnCheckXDB?.dateAdded || 0
            const bDate = b.createdAt || b.exploitDb?.date || b.vulnerabilityLab?.createdAt ||
                         b.crowdSec?.firstSeen || b.vulnCheckXDB?.dateAdded || 0
            return bDate - aDate
        })

        const response = {
            identifier: vulnId,
            timestamp: Math.floor(Date.now() / 1000),
            count: exploits.length,
            summary: {
                exploitDb: exploitReferences.filter(r => r.exploitDbId).length,
                metasploit: exploitReferences.filter(r =>
                    r.referenceSource?.toLowerCase().includes('metasploit') ||
                    r.url?.includes('/modules/exploits/')
                ).length,
                nuclei: exploitReferences.filter(r => r.nucleiPath).length,
                vulnerabilityLab: exploitReferences.filter(r => r.vlId).length,
                vulnCheckXDB: vulnCheckXDB.length,
                crowdSec: crowdSecSightings.length,
                github: exploitReferences.filter(r => r.prDiffUrl || r.gistId).length,
                other: exploitReferences.filter(r =>
                    !r.exploitDbId &&
                    !r.nucleiPath &&
                    !r.vlId &&
                    !r.prDiffUrl &&
                    !r.gistId &&
                    !r.referenceSource?.toLowerCase().includes('metasploit') &&
                    !r.url?.includes('/modules/exploits/')
                ).length
            },
            exploits
        }

        logger.info('Exploits retrieved', {
            identifier: vulnId,
            count: exploits.length,
            duration: Date.now() - startTime
        })

        return c.json(response)
    } catch (error) {
        logger.error('Error fetching exploits:', error)
        return c.json({
            success: false,
            error: 'Failed to fetch exploit information',
            details: error instanceof Error ? error.message : String(error)
        }, 500)
    }
})

export default app
