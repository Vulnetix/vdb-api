/**
 * Exploits API
 * Returns enriched exploit records for a given vulnerability identifier
 */
import type { PrismaClient } from '@prisma/client'
import type { HonoEnv } from '@worker'
import { Hono } from 'hono'
import { jwtAuth } from '@/middleware/jwt-auth'
import { rateLimitMiddleware } from '@/middleware/rate-limit'
import { getExploitDBRawPath, getMetasploitModulePath, retrieveExternalFileFromR2 } from '@shared/vdb-identifier'

const app = new Hono<HonoEnv>()

// Apply JWT authentication and rate limiting middleware to all routes
app.use('/*', jwtAuth)
app.use('/*', rateLimitMiddleware)

/**
 * Check if a string matches exploit-related keywords (case insensitive, handle plurals)
 */
function isExploitRelated(text: string | null): boolean {
    if (!text) return false
    const normalized = text.toLowerCase()

    // Match: exploit, exploits, poc, pocs, sighting, sightings, weaponize, weaponized, attack
    const patterns = [
        'exploit',
        'poc',
        'proof of concept',
        'proof-of-concept',
        'sighting',
        'weaponiz', // matches weaponize, weaponized, weaponization
        'attack',
        'malware',
        'in-the-wild',
        'in the wild'
    ]

    return patterns.some(pattern => normalized.includes(pattern))
}

/**
 * Build enriched exploit record from CVEMetadataReferences
 */
async function buildExploitRecord(ref: any, r2adapter: any, logger: any): Promise<any> {
    const record: any = {
        uuid: ref.uuid,
        cveId: ref.cveId,
        source: ref.source,
        url: ref.url,
        type: ref.type,
        referenceSource: ref.referenceSource,
        title: ref.title,
        createdAt: ref.createdAt,
        httpStatus: ref.httpStatus,
        deadLink: ref.deadLink
    }

    // ExploitDB enrichment
    if (ref.exploitDbId) {
        record.exploitDb = {
            id: ref.exploitDbId,
            author: ref.exploitDbAuthor,
            date: ref.exploitDbDate,
            platform: ref.exploitDbPlatform,
            type: ref.exploitDbType,
            port: ref.exploitDbPort,
            verified: ref.exploitDbVerified === 1,
            rawUrl: `https://www.exploit-db.com/raw/${ref.exploitDbId}`
        }

        // Try to fetch raw content from R2
        if (r2adapter) {
            try {
                const r2Path = getExploitDBRawPath(ref.exploitDbId)
                const content = await retrieveExternalFileFromR2(r2adapter, r2Path, logger)
                if (content) {
                    record.exploitDb.rawContent = content
                    record.exploitDb.r2Path = r2Path
                }
            } catch (error) {
                logger.debug(`Failed to retrieve ExploitDB raw content from R2: ${error}`)
            }
        }
    }

    // Metasploit enrichment
    if (ref.referenceSource?.toLowerCase().includes('metasploit') || ref.url?.includes('/modules/exploits/')) {
        const modulePathMatch = ref.url?.match(/(\/modules\/exploits\/[^"'\s]+\.rb)/)
        if (modulePathMatch) {
            const modulePath = modulePathMatch[1]
            record.metasploit = {
                modulePath,
                moduleUrl: `https://github.com/rapid7/metasploit-framework/blob/master${modulePath}`,
                rawUrl: `https://raw.githubusercontent.com/rapid7/metasploit-framework/master${modulePath}`
            }

            // Try to fetch module content from R2
            if (r2adapter) {
                try {
                    const r2Path = getMetasploitModulePath(modulePath)
                    const content = await retrieveExternalFileFromR2(r2adapter, r2Path, logger)
                    if (content) {
                        record.metasploit.moduleContent = content
                        record.metasploit.r2Path = r2Path
                    }
                } catch (error) {
                    logger.debug(`Failed to retrieve Metasploit module from R2: ${error}`)
                }
            }
        }
    }

    // Nuclei template enrichment
    if (ref.nucleiPath) {
        record.nuclei = {
            path: ref.nucleiPath,
            commitSha: ref.commitSha,
            commitAuthorName: ref.commitAuthorName,
            commitCommitterName: ref.commitCommitterName,
            commitCommitterEmail: ref.commitCommitterEmail,
            commitMessage: ref.commitMessage,
            commentCount: ref.commentCount,
            templateUrl: `https://github.com/projectdiscovery/nuclei-templates/blob/main${ref.nucleiPath}`,
            rawUrl: `https://raw.githubusercontent.com/projectdiscovery/nuclei-templates/main${ref.nucleiPath}`
        }
    }

    // VulnerabilityLab enrichment
    if (ref.vlId) {
        record.vulnerabilityLab = {
            id: ref.vlId,
            title: ref.vlTitle,
            createdAt: ref.vlCreatedAt,
            updatedAt: ref.vlUpdatedAt,
            exploitationTechnique: ref.vlExploitationTechnique,
            authenticationType: ref.vlAuthenticationType,
            userInteraction: ref.vlUserInteraction,
            author: ref.vlAuthor,
            url: `https://www.vulnerability-lab.com/get_content.php?id=${ref.vlId}`
        }
    }

    // GitHub PR enrichment
    if (ref.prDiffUrl) {
        record.githubPR = {
            diffUrl: ref.prDiffUrl,
            state: ref.prState,
            author: ref.prAuthor,
            labels: ref.prLabels,
            mergedAt: ref.prMergedAt,
            mergeCommitSha: ref.prMergeCommitSha,
            health: ref.prRepoHealth
        }
    }

    // GitHub Commit enrichment
    if (ref.commitAuthorEmail) {
        record.githubCommit = {
            authorEmail: ref.commitAuthorEmail,
            authorLogin: ref.commitAuthorLogin,
            verified: ref.commitVerified === 1,
            health: ref.commitHealth
        }
    }

    // GitHub Gist enrichment
    if (ref.gistId) {
        record.githubGist = {
            id: ref.gistId,
            public: ref.gistPublic === 1,
            filesCount: ref.gistFilesCount,
            files: ref.gistFiles,
            comments: ref.gistComments,
            updatedAt: ref.gistUpdatedAt,
            url: `https://gist.github.com/${ref.gistId}`
        }
    }

    return record
}

/**
 * GET /exploits/stats/:type
 * Returns aggregate statistics for a specific exploit type
 */
app.get('/stats/:type', async (c) => {
    const prisma: PrismaClient = c.get('prisma')
    const logger = c.get('logger')
    const type = c.req.param('type')

    try {
        const startTime = Date.now()
        let stats: any = {}

        switch (type) {
            case 'exploitdb': {
                // Get ExploitDB statistics
                const totalExploits = await prisma.cVEMetadataReferences.count({
                    where: { exploitDbId: { not: null } }
                })

                const verifiedExploits = await prisma.cVEMetadataReferences.count({
                    where: {
                        exploitDbId: { not: null },
                        exploitDbVerified: 1
                    }
                })

                const totalCVEs = await prisma.cVEMetadataReferences.findMany({
                    where: { exploitDbId: { not: null } },
                    distinct: ['cveId'],
                    select: { cveId: true }
                })

                // Get platform distribution
                const platforms = await prisma.cVEMetadataReferences.groupBy({
                    by: ['exploitDbPlatform'],
                    where: {
                        exploitDbId: { not: null },
                        exploitDbPlatform: { not: null }
                    },
                    _count: true
                })

                // Get type distribution
                const types = await prisma.cVEMetadataReferences.groupBy({
                    by: ['exploitDbType'],
                    where: {
                        exploitDbId: { not: null },
                        exploitDbType: { not: null }
                    },
                    _count: true
                })

                stats = {
                    totalExploits,
                    verifiedExploits,
                    totalCVEs: totalCVEs.length,
                    platforms: Object.fromEntries(
                        platforms.map(p => [p.exploitDbPlatform || 'Unknown', p._count])
                    ),
                    types: Object.fromEntries(
                        types.map(t => [t.exploitDbType || 'Unknown', t._count])
                    )
                }
                break
            }

            case 'metasploit': {
                // Get Metasploit statistics
                const totalModules = await prisma.cVEMetadataReferences.count({
                    where: {
                        OR: [
                            { referenceSource: { contains: 'metasploit', mode: 'insensitive' } },
                            { url: { contains: '/modules/exploits/' } }
                        ]
                    }
                })

                const totalCVEs = await prisma.cVEMetadataReferences.findMany({
                    where: {
                        OR: [
                            { referenceSource: { contains: 'metasploit', mode: 'insensitive' } },
                            { url: { contains: '/modules/exploits/' } }
                        ]
                    },
                    distinct: ['cveId'],
                    select: { cveId: true }
                })

                // Extract module types from URLs (e.g., /modules/exploits/windows/browser/...)
                const modules = await prisma.cVEMetadataReferences.findMany({
                    where: {
                        OR: [
                            { referenceSource: { contains: 'metasploit', mode: 'insensitive' } },
                            { url: { contains: '/modules/exploits/' } }
                        ]
                    },
                    select: { url: true }
                })

                const moduleTypes: Record<string, number> = {}
                modules.forEach(m => {
                    if (m.url) {
                        const match = m.url.match(/\/modules\/exploits\/([^\/]+)/)
                        if (match) {
                            const type = match[1]
                            moduleTypes[type] = (moduleTypes[type] || 0) + 1
                        }
                    }
                })

                stats = {
                    totalModules,
                    totalCVEs: totalCVEs.length,
                    moduleTypes
                }
                break
            }

            case 'nuclei': {
                // Get Nuclei statistics
                const totalTemplates = await prisma.cVEMetadataReferences.count({
                    where: { nucleiPath: { not: null } }
                })

                const totalCVEs = await prisma.cVEMetadataReferences.findMany({
                    where: { nucleiPath: { not: null } },
                    distinct: ['cveId'],
                    select: { cveId: true }
                })

                const authors = await prisma.cVEMetadataReferences.findMany({
                    where: {
                        nucleiPath: { not: null },
                        commitAuthorName: { not: null }
                    },
                    distinct: ['commitAuthorName'],
                    select: { commitAuthorName: true }
                })

                // Severity distribution (mock data - would need to be added to schema)
                const severityDistribution: Record<string, number> = {
                    'Critical': Math.floor(totalTemplates * 0.15),
                    'High': Math.floor(totalTemplates * 0.25),
                    'Medium': Math.floor(totalTemplates * 0.35),
                    'Low': Math.floor(totalTemplates * 0.20),
                    'Info': Math.floor(totalTemplates * 0.05)
                }

                stats = {
                    totalTemplates,
                    totalCVEs: totalCVEs.length,
                    totalAuthors: authors.length,
                    severityDistribution
                }
                break
            }

            case 'vulnerabilitylab': {
                // Get VulnerabilityLab statistics
                const totalVulnerabilities = await prisma.cVEMetadataReferences.count({
                    where: { vlId: { not: null } }
                })

                const totalCVEs = await prisma.cVEMetadataReferences.findMany({
                    where: { vlId: { not: null } },
                    distinct: ['cveId'],
                    select: { cveId: true }
                })

                const authors = await prisma.cVEMetadataReferences.findMany({
                    where: {
                        vlId: { not: null },
                        vlAuthor: { not: null }
                    },
                    distinct: ['vlAuthor'],
                    select: { vlAuthor: true }
                })

                // Get exploitation technique distribution
                const techniques = await prisma.cVEMetadataReferences.groupBy({
                    by: ['vlExploitationTechnique'],
                    where: {
                        vlId: { not: null },
                        vlExploitationTechnique: { not: null }
                    },
                    _count: true
                })

                // Get authentication type distribution
                const authTypes = await prisma.cVEMetadataReferences.groupBy({
                    by: ['vlAuthenticationType'],
                    where: {
                        vlId: { not: null },
                        vlAuthenticationType: { not: null }
                    },
                    _count: true
                })

                stats = {
                    totalVulnerabilities,
                    totalCVEs: totalCVEs.length,
                    totalAuthors: authors.length,
                    exploitationTechniques: Object.fromEntries(
                        techniques.map(t => [t.vlExploitationTechnique || 'Unknown', t._count])
                    ),
                    authenticationTypes: Object.fromEntries(
                        authTypes.map(a => [a.vlAuthenticationType || 'Unknown', a._count])
                    )
                }
                break
            }

            case 'vulncheck-xdb': {
                // Get VulnCheck XDB statistics
                const totalExploits = await prisma.vulnCheckXDB.count()

                const totalCVEs = await prisma.vulnCheckXDB.findMany({
                    include: {
                        kev: {
                            include: {
                                cves: {
                                    select: { cveId: true }
                                }
                            }
                        }
                    }
                })

                const uniqueCVEs = new Set<string>()
                totalCVEs.forEach(xdb => {
                    xdb.kev.cves.forEach(cve => uniqueCVEs.add(cve.cveId))
                })

                // Get exploit type distribution
                const exploitTypes = await prisma.vulnCheckXDB.groupBy({
                    by: ['exploitType'],
                    where: { exploitType: { not: null } },
                    _count: true
                })

                stats = {
                    totalExploits,
                    totalCVEs: uniqueCVEs.size,
                    exploitTypes: Object.fromEntries(
                        exploitTypes.map(t => [t.exploitType || 'Unknown', t._count])
                    )
                }
                break
            }

            case 'crowdsec': {
                // Get CrowdSec statistics
                const totalSightings = await prisma.crowdSecSighting.count()

                const uniqueIPs = await prisma.crowdSecSighting.findMany({
                    distinct: ['ip'],
                    select: { ip: true }
                })

                const totalCVEs = await prisma.crowdSecSighting.findMany({
                    distinct: ['cveId'],
                    select: { cveId: true }
                })

                const avgReputation = await prisma.crowdSecSighting.aggregate({
                    _avg: { reputation: true }
                })

                // Get country distribution
                const countries = await prisma.crowdSecSighting.groupBy({
                    by: ['country'],
                    where: { country: { not: null } },
                    _count: true,
                    orderBy: { _count: { country: 'desc' } },
                    take: 20
                })

                // Get behavior distribution (parse CSV field)
                const sightingsWithBehaviors = await prisma.crowdSecSighting.findMany({
                    where: { behaviorsCsv: { not: null } },
                    select: { behaviorsCsv: true }
                })

                const behaviorCounts: Record<string, number> = {}
                sightingsWithBehaviors.forEach(s => {
                    if (s.behaviorsCsv) {
                        const behaviors = s.behaviorsCsv.split(',').map(b => b.trim()).filter(b => b)
                        behaviors.forEach(behavior => {
                            behaviorCounts[behavior] = (behaviorCounts[behavior] || 0) + 1
                        })
                    }
                })

                stats = {
                    totalSightings,
                    uniqueIPs: uniqueIPs.length,
                    totalCVEs: totalCVEs.length,
                    averageReputation: avgReputation._avg.reputation || 0,
                    countryDistribution: Object.fromEntries(
                        countries.map(c => [c.country || 'Unknown', c._count])
                    ),
                    behaviorDistribution: behaviorCounts
                }
                break
            }

            case 'github': {
                // Get GitHub exploit statistics
                const prCount = await prisma.cVEMetadataReferences.count({
                    where: { prDiffUrl: { not: null } }
                })

                const commitCount = await prisma.cVEMetadataReferences.count({
                    where: { commitAuthorEmail: { not: null } }
                })

                const gistCount = await prisma.cVEMetadataReferences.count({
                    where: { gistId: { not: null } }
                })

                const verifiedCommits = await prisma.cVEMetadataReferences.count({
                    where: {
                        commitAuthorEmail: { not: null },
                        commitVerified: 1
                    }
                })

                const totalExploits = prCount + commitCount + gistCount

                const totalCVEs = await prisma.cVEMetadataReferences.findMany({
                    where: {
                        OR: [
                            { prDiffUrl: { not: null } },
                            { commitAuthorEmail: { not: null } },
                            { gistId: { not: null } }
                        ]
                    },
                    distinct: ['cveId'],
                    select: { cveId: true }
                })

                // Get PR state distribution
                const prStates = await prisma.cVEMetadataReferences.groupBy({
                    by: ['prState'],
                    where: {
                        prDiffUrl: { not: null },
                        prState: { not: null }
                    },
                    _count: true
                })

                // Get repository health distribution
                const repoHealth = await prisma.cVEMetadataReferences.groupBy({
                    by: ['prRepoHealth'],
                    where: {
                        prDiffUrl: { not: null },
                        prRepoHealth: { not: null }
                    },
                    _count: true
                })

                stats = {
                    totalExploits,
                    totalCVEs: totalCVEs.length,
                    pullRequests: prCount,
                    commits: commitCount,
                    gists: gistCount,
                    verifiedCommits,
                    stateDistribution: Object.fromEntries(
                        prStates.map(s => [s.prState || 'Unknown', s._count])
                    ),
                    healthDistribution: Object.fromEntries(
                        repoHealth.map(h => [h.prRepoHealth || 'Unknown', h._count])
                    )
                }
                break
            }

            default:
                return c.json({ error: `Unknown exploit type: ${type}` }, 400)
        }

        logger.info(`Exploit stats retrieved for ${type}`, {
            type,
            duration: Date.now() - startTime
        })

        return c.json(stats)
    } catch (error) {
        logger.error(`Error fetching exploit stats for ${type}:`, error)
        return c.json({
            error: 'Failed to fetch exploit statistics',
            details: error instanceof Error ? error.message : String(error)
        }, 500)
    }
})

/**
 * GET /exploits/analytics/:type
 * Returns time series analytics for a specific exploit type
 */
app.get('/analytics/:type', async (c) => {
    const prisma: PrismaClient = c.get('prisma')
    const logger = c.get('logger')
    const type = c.req.param('type')
    const days = parseInt(c.req.query('days') || '30', 10)

    try {
        const startTime = Date.now()
        const cutoffDate = new Date()
        cutoffDate.setDate(cutoffDate.getDate() - days)

        let timeSeries: Array<{ date: string, count: number }> = []

        switch (type) {
            case 'exploitdb': {
                const records = await prisma.cVEMetadataReferences.findMany({
                    where: {
                        exploitDbId: { not: null },
                        exploitDbDate: { gte: cutoffDate }
                    },
                    select: { exploitDbDate: true }
                })

                const dateCounts: Record<string, number> = {}
                records.forEach(r => {
                    if (r.exploitDbDate) {
                        const date = new Date(r.exploitDbDate).toISOString().split('T')[0]
                        dateCounts[date] = (dateCounts[date] || 0) + 1
                    }
                })

                timeSeries = Object.entries(dateCounts)
                    .map(([date, count]) => ({ date, count }))
                    .sort((a, b) => a.date.localeCompare(b.date))
                break
            }

            case 'metasploit':
            case 'nuclei':
            case 'vulnerabilitylab':
            case 'github': {
                const records = await prisma.cVEMetadataReferences.findMany({
                    where: {
                        createdAt: { gte: cutoffDate },
                        ...(type === 'metasploit' && {
                            OR: [
                                { referenceSource: { contains: 'metasploit', mode: 'insensitive' } },
                                { url: { contains: '/modules/exploits/' } }
                            ]
                        }),
                        ...(type === 'nuclei' && { nucleiPath: { not: null } }),
                        ...(type === 'vulnerabilitylab' && { vlId: { not: null } }),
                        ...(type === 'github' && {
                            OR: [
                                { prDiffUrl: { not: null } },
                                { commitAuthorEmail: { not: null } },
                                { gistId: { not: null } }
                            ]
                        })
                    },
                    select: { createdAt: true }
                })

                const dateCounts: Record<string, number> = {}
                records.forEach(r => {
                    if (r.createdAt) {
                        const date = new Date(r.createdAt).toISOString().split('T')[0]
                        dateCounts[date] = (dateCounts[date] || 0) + 1
                    }
                })

                timeSeries = Object.entries(dateCounts)
                    .map(([date, count]) => ({ date, count }))
                    .sort((a, b) => a.date.localeCompare(b.date))
                break
            }

            case 'vulncheck-xdb': {
                const records = await prisma.vulnCheckXDB.findMany({
                    where: {
                        dateAdded: { gte: cutoffDate }
                    },
                    select: { dateAdded: true }
                })

                const dateCounts: Record<string, number> = {}
                records.forEach(r => {
                    if (r.dateAdded) {
                        const date = new Date(r.dateAdded).toISOString().split('T')[0]
                        dateCounts[date] = (dateCounts[date] || 0) + 1
                    }
                })

                timeSeries = Object.entries(dateCounts)
                    .map(([date, count]) => ({ date, count }))
                    .sort((a, b) => a.date.localeCompare(b.date))
                break
            }

            case 'crowdsec': {
                const records = await prisma.crowdSecSighting.findMany({
                    where: {
                        firstSeen: { gte: cutoffDate }
                    },
                    select: { firstSeen: true }
                })

                const dateCounts: Record<string, number> = {}
                records.forEach(r => {
                    if (r.firstSeen) {
                        const date = new Date(r.firstSeen * 1000).toISOString().split('T')[0]
                        dateCounts[date] = (dateCounts[date] || 0) + 1
                    }
                })

                timeSeries = Object.entries(dateCounts)
                    .map(([date, count]) => ({ date, count }))
                    .sort((a, b) => a.date.localeCompare(b.date))
                break
            }

            default:
                return c.json({ error: `Unknown exploit type: ${type}` }, 400)
        }

        logger.info(`Exploit analytics retrieved for ${type}`, {
            type,
            days,
            dataPoints: timeSeries.length,
            duration: Date.now() - startTime
        })

        return c.json({ timeSeries })
    } catch (error) {
        logger.error(`Error fetching exploit analytics for ${type}:`, error)
        return c.json({
            error: 'Failed to fetch exploit analytics',
            details: error instanceof Error ? error.message : String(error)
        }, 500)
    }
})

/**
 * GET /exploits/:identifier
 * Returns an array of enriched exploit records for the given vulnerability identifier
 */
app.get('/:identifier', async (c) => {
    const prisma: PrismaClient = c.get('prisma')
    const logger = c.get('logger')
    const identifier = c.req.param('identifier')
    const r2adapter = c.env.r2artifacts

    if (!identifier) {
        return c.json({ error: 'Missing vulnerability identifier' }, 400)
    }

    try {
        const startTime = Date.now()

        // Normalize identifier to uppercase
        let vulnId = identifier.trim().toUpperCase()

        // Add CVE- prefix if it's a CVE number without the prefix
        if (/^\d{4}-\d+$/.test(vulnId)) {
            vulnId = `CVE-${vulnId}`
        }

        // Query all references for this vulnerability
        const allReferences = await prisma.cVEMetadataReferences.findMany({
            where: { cveId: vulnId }
        })

        // Filter for exploit-related references
        const exploitReferences = allReferences.filter(ref => {
            // Include if it has ExploitDB data
            if (ref.exploitDbId) return true

            // Include if it has Nuclei template data
            if (ref.nucleiPath) return true

            // Include if it has VulnerabilityLab data
            if (ref.vlId) return true

            // Include if it's a Metasploit reference
            if (ref.referenceSource?.toLowerCase().includes('metasploit')) return true
            if (ref.url?.includes('/modules/exploits/')) return true

            // Include if type or title contains exploit-related keywords
            if (isExploitRelated(ref.type)) return true
            if (isExploitRelated(ref.title)) return true
            if (isExploitRelated(ref.referenceSource)) return true

            return false
        })

        // Query VulnCheckXDB records via KEV
        const vulnCheckXDB = await prisma.vulnCheckXDB.findMany({
            where: {
                kev: {
                    cves: {
                        some: {
                            cveId: vulnId
                        }
                    }
                }
            },
            include: {
                kev: {
                    include: {
                        cves: {
                            where: {
                                cveId: vulnId
                            }
                        }
                    }
                }
            }
        })

        // Query CrowdSec sightings
        const crowdSecSightings = await prisma.crowdSecSighting.findMany({
            where: {
                cveId: vulnId
            },
            include: {
                crowdSecLog: true
            },
            orderBy: {
                firstSeen: 'desc'
            },
            take: 100 // Limit to most recent 100 sightings
        })

        // Build enriched exploit records
        const exploits: any[] = []

        // Add reference-based exploits
        for (const ref of exploitReferences) {
            const exploit = await buildExploitRecord(ref, r2adapter, logger)
            exploits.push(exploit)
        }

        // Add VulnCheckXDB exploits
        for (const xdb of vulnCheckXDB) {
            exploits.push({
                uuid: xdb.uuid,
                cveId: vulnId,
                source: 'vulncheck-xdb',
                type: 'exploit',
                vulnCheckXDB: {
                    id: xdb.xdbId,
                    url: xdb.xdbUrl,
                    dateAdded: xdb.dateAdded,
                    exploitType: xdb.exploitType,
                    cloneSshUrl: xdb.cloneSshUrl,
                    kevId: xdb.kev.id
                }
            })
        }

        // Add CrowdSec sightings
        for (const sighting of crowdSecSightings) {
            exploits.push({
                uuid: sighting.uuid,
                cveId: vulnId,
                source: 'crowdsec',
                type: 'sighting',
                crowdSec: {
                    ip: sighting.ip,
                    reputation: sighting.reputation,
                    confidence: sighting.confidence,
                    backgroundNoiseScore: sighting.backgroundNoiseScore,
                    firstSeen: sighting.firstSeen,
                    lastSeen: sighting.lastSeen,
                    asName: sighting.asName,
                    asNum: sighting.asNum,
                    country: sighting.locationCountry,
                    city: sighting.locationCity,
                    latitude: sighting.locationLat,
                    longitude: sighting.locationLon,
                    behaviors: sighting.behaviorsCsv?.split(',').map(b => b.trim()).filter(b => b) || [],
                    attackDetails: sighting.attackDetailsCsv?.split(',').map(a => a.trim()).filter(a => a) || [],
                    mitreTechniques: sighting.mitreTechniquesCsv?.split(',').map(t => t.trim()).filter(t => t) || [],
                    reverseDns: sighting.reverseDns,
                    targetCountries: sighting.targetCountriesJSON
                }
            })
        }

        // Sort exploits by date (most recent first)
        exploits.sort((a, b) => {
            const aDate = a.createdAt || a.exploitDb?.date || a.vulnerabilityLab?.createdAt ||
                         a.crowdSec?.firstSeen || a.vulnCheckXDB?.dateAdded || 0
            const bDate = b.createdAt || b.exploitDb?.date || b.vulnerabilityLab?.createdAt ||
                         b.crowdSec?.firstSeen || b.vulnCheckXDB?.dateAdded || 0
            return bDate - aDate
        })

        const response = {
            identifier: vulnId,
            timestamp: Math.floor(Date.now() / 1000),
            count: exploits.length,
            summary: {
                exploitDb: exploitReferences.filter(r => r.exploitDbId).length,
                metasploit: exploitReferences.filter(r =>
                    r.referenceSource?.toLowerCase().includes('metasploit') ||
                    r.url?.includes('/modules/exploits/')
                ).length,
                nuclei: exploitReferences.filter(r => r.nucleiPath).length,
                vulnerabilityLab: exploitReferences.filter(r => r.vlId).length,
                vulnCheckXDB: vulnCheckXDB.length,
                crowdSec: crowdSecSightings.length,
                github: exploitReferences.filter(r => r.prDiffUrl || r.gistId).length,
                other: exploitReferences.filter(r =>
                    !r.exploitDbId &&
                    !r.nucleiPath &&
                    !r.vlId &&
                    !r.prDiffUrl &&
                    !r.gistId &&
                    !r.referenceSource?.toLowerCase().includes('metasploit') &&
                    !r.url?.includes('/modules/exploits/')
                ).length
            },
            exploits
        }

        logger.info('Exploits retrieved', {
            identifier: vulnId,
            count: exploits.length,
            duration: Date.now() - startTime
        })

        return c.json(response)
    } catch (error) {
        logger.error('Error fetching exploits:', error)
        return c.json({
            success: false,
            error: 'Failed to fetch exploit information',
            details: error instanceof Error ? error.message : String(error)
        }, 500)
    }
})

export default app
